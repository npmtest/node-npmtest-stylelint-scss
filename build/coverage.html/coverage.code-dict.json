{"/home/travis/build/npmtest/node-npmtest-stylelint-scss/test.js":"/* istanbul instrument in package npmtest_stylelint_scss */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-stylelint-scss/lib.npmtest_stylelint_scss.js":"/* istanbul instrument in package npmtest_stylelint_scss */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_stylelint_scss = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_stylelint_scss = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-stylelint-scss/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-stylelint-scss && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_stylelint_scss */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_stylelint_scss\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_stylelint_scss.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_stylelint_scss.rollup.js'] =\n            local.assetsDict['/assets.npmtest_stylelint_scss.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_stylelint_scss.__dirname + '/lib.npmtest_stylelint_scss.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _stylelint = require(\"stylelint\");\n\nvar _utils = require(\"./utils\");\n\nvar _rules = require(\"./rules\");\n\nvar _rules2 = _interopRequireDefault(_rules);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar rulesPlugins = Object.keys(_rules2.default).map(function (ruleName) {\n  return (0, _stylelint.createPlugin)((0, _utils.namespace)(ruleName), _rules2.default[ruleName]);\n});\n\nexports.default = rulesPlugins;","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _atRuleParamIndex = require(\"./atRuleParamIndex\");\n\nObject.defineProperty(exports, \"atRuleParamIndex\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_atRuleParamIndex).default;\n  }\n});\n\nvar _beforeBlockString = require(\"./beforeBlockString\");\n\nObject.defineProperty(exports, \"beforeBlockString\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_beforeBlockString).default;\n  }\n});\n\nvar _blockString = require(\"./blockString\");\n\nObject.defineProperty(exports, \"blockString\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_blockString).default;\n  }\n});\n\nvar _declarationValueIndex = require(\"./declarationValueIndex\");\n\nObject.defineProperty(exports, \"declarationValueIndex\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_declarationValueIndex).default;\n  }\n});\n\nvar _findCommentsInRaws = require(\"./findCommentsInRaws\");\n\nObject.defineProperty(exports, \"findCommentsInRaws\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_findCommentsInRaws).default;\n  }\n});\n\nvar _hasInterpolatingAmpersand = require(\"./hasInterpolatingAmpersand\");\n\nObject.defineProperty(exports, \"hasInterpolatingAmpersand\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_hasInterpolatingAmpersand).default;\n  }\n});\n\nvar _hasBlock = require(\"./hasBlock\");\n\nObject.defineProperty(exports, \"hasBlock\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_hasBlock).default;\n  }\n});\n\nvar _hasEmptyLine = require(\"./hasEmptyLine\");\n\nObject.defineProperty(exports, \"hasEmptyLine\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_hasEmptyLine).default;\n  }\n});\n\nvar _isInlineComment = require(\"./isInlineComment\");\n\nObject.defineProperty(exports, \"isInlineComment\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_isInlineComment).default;\n  }\n});\n\nvar _isSingleLineString = require(\"./isSingleLineString\");\n\nObject.defineProperty(exports, \"isSingleLineString\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_isSingleLineString).default;\n  }\n});\n\nvar _isStandardRule = require(\"./isStandardRule\");\n\nObject.defineProperty(exports, \"isStandardRule\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_isStandardRule).default;\n  }\n});\n\nvar _isStandardSelector = require(\"./isStandardSelector\");\n\nObject.defineProperty(exports, \"isStandardSelector\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_isStandardSelector).default;\n  }\n});\n\nvar _isStandardSyntaxProperty = require(\"./isStandardSyntaxProperty\");\n\nObject.defineProperty(exports, \"isStandardSyntaxProperty\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_isStandardSyntaxProperty).default;\n  }\n});\n\nvar _isWhitespace = require(\"./isWhitespace\");\n\nObject.defineProperty(exports, \"isWhitespace\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_isWhitespace).default;\n  }\n});\n\nvar _namespace = require(\"./namespace\");\n\nObject.defineProperty(exports, \"namespace\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_namespace).default;\n  }\n});\n\nvar _optionsHaveException = require(\"./optionsHaveException\");\n\nObject.defineProperty(exports, \"optionsHaveException\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_optionsHaveException).default;\n  }\n});\n\nvar _optionsHaveIgnored = require(\"./optionsHaveIgnored\");\n\nObject.defineProperty(exports, \"optionsHaveIgnored\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_optionsHaveIgnored).default;\n  }\n});\n\nvar _parseNestedPropRoot = require(\"./parseNestedPropRoot\");\n\nObject.defineProperty(exports, \"parseNestedPropRoot\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_parseNestedPropRoot).default;\n  }\n});\n\nvar _parseSelector = require(\"./parseSelector\");\n\nObject.defineProperty(exports, \"parseSelector\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_parseSelector).default;\n  }\n});\n\nvar _sassValueParser = require(\"./sassValueParser\");\n\nObject.defineProperty(exports, \"findOperators\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_sassValueParser).default;\n  }\n});\n\nvar _rawNodeString = require(\"./rawNodeString\");\n\nObject.defineProperty(exports, \"rawNodeString\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_rawNodeString).default;\n  }\n});\n\nvar _whitespaceChecker = require(\"./whitespaceChecker\");\n\nObject.defineProperty(exports, \"whitespaceChecker\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_whitespaceChecker).default;\n  }\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/atRuleParamIndex.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (atRule) {\n  // Initial 1 is for the `@`\n  var index = 1 + atRule.name.length;\n  if (atRule.raw(\"afterName\")) {\n    index += atRule.raw(\"afterName\").length;\n  }\n  return index;\n};","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/beforeBlockString.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (statement) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      noRawBefore = _ref.noRawBefore;\n\n  var result = \"\";\n  if (statement.type !== \"rule\" && statement.type !== \"atrule\") {\n    return result;\n  }\n\n  if (!noRawBefore) {\n    result += statement.raws.before;\n  }\n  if (statement.type === \"rule\") {\n    result += statement.selector;\n  } else {\n    result += \"@\" + statement.name + statement.raws.afterName + statement.params;\n  }\n\n  var between = statement.raws.between;\n\n  if (between !== undefined) {\n    result += between;\n  }\n\n  return result;\n};","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/blockString.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (statement) {\n  if (!(0, _hasBlock2.default)(statement)) {\n    return;\n  }\n  return (0, _rawNodeString2.default)(statement).slice((0, _beforeBlockString2.default)(statement).length);\n};\n\nvar _beforeBlockString = require(\"./beforeBlockString\");\n\nvar _beforeBlockString2 = _interopRequireDefault(_beforeBlockString);\n\nvar _hasBlock = require(\"./hasBlock\");\n\nvar _hasBlock2 = _interopRequireDefault(_hasBlock);\n\nvar _rawNodeString = require(\"./rawNodeString\");\n\nvar _rawNodeString2 = _interopRequireDefault(_rawNodeString);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/hasBlock.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (statement) {\n  return statement.nodes !== undefined;\n};","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/rawNodeString.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (node) {\n  var result = \"\";\n  if (node.raws.before) {\n    result += node.raws.before;\n  }\n  result += node.toString();\n  return result;\n};","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/declarationValueIndex.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (decl) {\n  var beforeColon = decl.toString().indexOf(\":\");\n  var afterColon = decl.raw(\"between\").length - decl.raw(\"between\").indexOf(\":\");\n  return beforeColon + afterColon;\n};","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/findCommentsInRaws.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = findCommentsInRaws;\n\nvar _lodash = require(\"lodash\");\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Finds comments, both CSS comments and double slash ones, in a CSS string\n * This helper exists because PostCSS drops some inline comments (those\n * between seelctors, property values, etc.)\n * https://github.com/postcss/postcss/issues/845#issuecomment-232306259\n *\n * @param [string] rawString -- the source raw CSS string\n * @return [array] array of objects with these props:\n *    � type -- \"css\" or \"double-slash\"\n *    � source: { start, end }\n *      IMPORTANT: the function itself considers \\r as a character, and counts\n *      it for `start` and `end`. But if their values are passed to PostCSS's\n *      result.warn(), than \"\\r\\n\" is consideren ONE CHAR (newline)!\n *    � raws\n *      raws.startToken -- `/*`, `/**`, `/**!`, etc.\n *      raws.left -- whitespace after the comment opening marker\n *      raws.text -- the full comment, including markers (//, /*)\n *      raws.right -- whitespace before the comment closing marker\n *      raws.endToken -- `*\\/`, `**\\/` for CSS comments\n *    � text -- the comment text only, excluding //, /*, trailing whitespaces\n *    � inlineAfter -- true, if there is something before the comment on\n *      the same line\n *    � inlineBefore -- true, if there is something after the comment on\n *      the same line\n */\n\nfunction findCommentsInRaws(rawString) {\n  var result = [];\n  var comment = {};\n  // Keeps track of which structure the parser is inside (string, comment,\n  // url function, parens). E.g., /* comment */ inside a string doesn't\n  // constitute a comment, so as url(//path)\n  var modesEntered = [{\n    mode: \"normal\",\n    character: null\n  }];\n  var commentStart = null;\n\n  // postcss-scss transforms //-comments into CSS comments, like so:\n  // `// comment` -> `/* comment*/`. So to have a correct intex we need to\n  // keep track on the added `*/` sequences\n  var offset = 0;\n\n  for (var i = 0; i < rawString.length; i++) {\n    var character = rawString[i];\n    var prevChar = i > 0 ? rawString[i - 1] : null;\n    var nextChar = i + 1 < rawString.length ? rawString[i + 1] : null;\n\n    var lastModeIndex = modesEntered.length - 1;\n    var mode = modesEntered[lastModeIndex].mode;\n\n    switch (character) {\n      // If entering/exiting a string\n      case \"\\\"\":\n      case \"'\":\n        {\n          if (mode === \"comment\") {\n            break;\n          }\n          if (mode === \"string\" && modesEntered[lastModeIndex].character === character && prevChar !== \"\\\\\") {\n            // Exiting a string\n            modesEntered.pop();\n          } else {\n            // Entering a string\n            modesEntered.push({\n              mode: \"string\",\n              character: character\n            });\n          }\n          break;\n        }\n      // Entering url, other function or parens (only url matters)\n      case \"(\":\n        {\n          if (mode === \"comment\" || mode === \"string\") {\n            break;\n          }\n          var functionNameRegSearch = /(?:^|(?:\\n)|(?:\\r)|(?:\\s-)|[:\\s,.(){}*+/%])([a-zA-Z0-9_-]*)$/.exec(rawString.substring(0, i));\n          // A `\\S(` can be in, say, `@media(`\n          if (!functionNameRegSearch) {\n            modesEntered.push({\n              mode: \"parens\",\n              character: \"(\"\n            });\n            break;\n          }\n\n          var functionName = functionNameRegSearch[1];\n          modesEntered.push({\n            mode: functionName === \"url\" ? \"url\" : \"parens\",\n            character: \"(\"\n          });\n          break;\n        }\n      // Exiting url, other function or parens\n      case \")\":\n        {\n          if (mode === \"comment\" || mode === \"string\") {\n            break;\n          }\n          modesEntered.pop();\n          break;\n        }\n      // checking for comment\n      case \"/\":\n        {\n          // Break if the / is inside a comment because we leap over the second\n          // slash in // and in */, so the / is not from a marker. Also break\n          // if inside a string\n          if (mode === \"comment\" || mode === \"string\") {\n            break;\n          }\n          if (nextChar === \"*\") {\n            modesEntered.push({\n              mode: \"comment\",\n              character: \"/*\"\n            });\n            comment = {\n              type: \"css\",\n              source: { start: i + offset },\n              // If i is 0 then the file/the line starts with this comment\n              inlineAfter: i > 0 && rawString.substring(0, i).search(/\\n\\s*$/) === -1\n            };\n            commentStart = i;\n            // Skip the next iteration as the * is already checked\n            i++;\n          } else if (nextChar === \"/\") {\n            // `url(//path/to/file)` has no comment\n            if (mode === \"url\") {\n              break;\n            }\n            modesEntered.push({\n              mode: \"comment\",\n              character: \"//\"\n            });\n            comment = {\n              type: \"double-slash\",\n              source: { start: i + offset },\n              // If i is 0 then the file/the line starts with this comment\n              inlineAfter: i > 0 && rawString.substring(0, i).search(/\\n\\s*$/) === -1\n            };\n            commentStart = i;\n            // Skip the next iteration as the second slash in // is already checked\n            i++;\n          }\n          break;\n        }\n      // Might be a closing `*/`\n      case \"*\":\n        {\n          if (mode === \"comment\" && modesEntered[lastModeIndex].character === \"/*\" && nextChar === \"/\") {\n            comment.source.end = i + 1 + offset;\n\n            var commentRaw = rawString.substring(commentStart, i + 2);\n            var matches = /^(\\/\\*+[!#]{0,1})(\\s*)([\\s\\S]*?)(\\s*?)(\\*+\\/)$/.exec(commentRaw);\n            modesEntered.pop();\n            comment.raws = {\n              startToken: matches[1],\n              left: matches[2],\n              text: commentRaw,\n              right: matches[4],\n              endToken: matches[5]\n            };\n            comment.text = matches[3];\n            comment.inlineBefore = rawString.substring(i + 2).search(/^\\s*?\\S+\\s*?\\n/) !== -1;\n            result.push(_lodash2.default.assign({}, comment));\n            comment = {};\n            // Skip the next loop as the / in */ is already checked\n            i++;\n          }\n          break;\n        }\n      default:\n        {\n          var isNewline = character === \"\\r\" && rawString[i + 1] === \"\\n\" || character === \"\\n\" && rawString[i - 1] !== \"\\r\";\n          // //-comments end before newline and if the code string ends\n          if (isNewline || i === rawString.length - 1) {\n            if (mode === \"comment\" && modesEntered[lastModeIndex].character === \"//\") {\n              comment.source.end = (isNewline ? i - 1 : i) + offset;\n\n              var _commentRaw = rawString.substring(commentStart, isNewline ? i : i + 1);\n              var _matches = /^(\\/+)(\\s*)(.*?)(\\s*?)$/.exec(_commentRaw);\n\n              modesEntered.pop();\n              comment.raws = {\n                startToken: _matches[1],\n                left: _matches[2],\n                text: _commentRaw,\n                right: _matches[4]\n              };\n              comment.text = _matches[3];\n              comment.inlineBefore = false;\n              result.push(_lodash2.default.assign({}, comment));\n              comment = {};\n              // Compensate for the `*/` added by postcss-scss\n              offset += 2;\n            }\n          }\n          break;\n        }\n    }\n  }\n\n  return result;\n}","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/hasInterpolatingAmpersand.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (selector) {\n  for (var i = 0; i < selector.length; i++) {\n    if (selector[i] !== \"&\") {\n      continue;\n    }\n    if (!_lodash2.default.isUndefined(selector[i - 1]) && !isCombinator(selector[i - 1])) {\n      return true;\n    }\n    if (!_lodash2.default.isUndefined(selector[i + 1]) && !isCombinator(selector[i + 1])) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvar _lodash = require(\"lodash\");\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isCombinator(x) {\n  return (/[\\s+>~]/.test(x)\n  );\n}\n\n/**\n * Check whether a selector has an interpolating ampersand\n * An \"interpolating ampersand\" is an \"&\" used to interpolate within another\n * simple selector (e.g. `&-modifier`), rather than an \"&\" that stands\n * on its own as a simple selector (e.g. `& .child`)\n *\n * @param {string} selector\n * @return {boolean} If `true`, the selector has an interpolating ampersand\n */","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/hasEmptyLine.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (string) {\n  return string && (string.indexOf(\"\\n\\n\") !== -1 || string.indexOf(\"\\n\\r\\n\") !== -1);\n};","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/isInlineComment.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isInlineComment;\n/**\n * Check if a comment is inline one (i.e. on the same line as some non-comment\n * code). Only works with comments that are not ignored by PostCSS. To work\n * with those that are ignored use `findCommentInRaws`\n *\n * @param {Comment} comment - PostCSS comment node\n * @return {boolean} true, if the comment is an inline one\n */\n\nfunction isInlineComment(comment) {\n  var nextNode = comment.next();\n  var isBeforeSomething = !!nextNode && nextNode.type !== \"comment\" && comment.source.end.line === nextNode.source.start.line;\n  var isAfterSomething = comment.raws.before.search(/\\n/) === -1;\n\n  return isAfterSomething || isBeforeSomething;\n}","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/isSingleLineString.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (input) {\n  return !/[\\n\\r]/.test(input);\n};","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/isStandardRule.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (rule) {\n\n  // Get full selector\n  var selector = _lodash2.default.get(rule, \"raws.selector.raw\", rule.selector);\n\n  // Custom property set (e.g. --custom-property-set: {})\n  if (_lodash2.default.endsWith(selector, \":\")) {\n    return false;\n  }\n\n  // Called Less mixin (e.g. a { .mixin() })\n  if (rule.ruleWithoutBody) {\n    return false;\n  }\n\n  // Non-outputting Less mixin definition (e.g. .mixin() {})\n  if (_lodash2.default.endsWith(selector, \")\") && !_lodash2.default.includes(selector, \":\")) {\n    return false;\n  }\n\n  return true;\n};\n\nvar _lodash = require(\"lodash\");\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/isStandardSelector.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (selector) {\n\n  // SCSS or Less interpolation\n  if (/#{.+?}|@{.+?}|\\$\\(.+?\\)/.test(selector)) {\n    return false;\n  }\n\n  return true;\n};","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/isStandardSyntaxProperty.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (property) {\n\n  // SCSS var (e.g. $var: x), list (e.g. $list: (x)) or map (e.g. $map: (key:value))\n  if (property[0] === \"$\") {\n    return false;\n  }\n\n  // Less var (e.g. @var: x)\n  if (property[0] === \"@\") {\n    return false;\n  }\n\n  // SCSS or Less interpolation\n  if (/#{.+?}|@{.+?}|\\$\\(.+?\\)/.test(property)) {\n    return false;\n  }\n\n  return true;\n};","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/isWhitespace.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (char) {\n  return [\" \", \"\\n\", \"\\t\", \"\\r\", \"\\f\"].indexOf(char) !== -1;\n};","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/namespace.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = namespace;\nvar prefix = \"scss\";\n\nfunction namespace(ruleName) {\n  return prefix + \"/\" + ruleName;\n}","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/optionsHaveException.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (options, exceptionName) {\n  return options && options.except && options.except.indexOf(exceptionName) !== -1;\n};","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/optionsHaveIgnored.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (options, ignoredName) {\n  return options && options.ignore && options.ignore.indexOf(ignoredName) !== -1;\n};","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/parseNestedPropRoot.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseNestedPropRoot;\n/**\n * Attempts to parse a selector as if it\"s a root for a group of nested props\n * E.g.: `margin: {`, `font: 10px/1.1 Arial {` (\"{\" excluded)\n */\n\nfunction parseNestedPropRoot(propString) {\n  var modesEntered = [{\n    mode: \"normal\",\n    character: null,\n    isCalculationEnabled: true\n  }];\n  var result = {};\n  var lastModeIndex = 0;\n  var propName = \"\";\n\n  for (var i = 0; i < propString.length; i++) {\n    var character = propString[i];\n\n    // If entering/exiting a string\n    if (character === \"\\\"\" || character === \"'\") {\n      if (modesEntered[lastModeIndex].isCalculationEnabled === true) {\n        modesEntered.push({\n          mode: \"string\",\n          isCalculationEnabled: false,\n          character: character\n        });\n        lastModeIndex++;\n      } else if (modesEntered[lastModeIndex].mode === \"string\" && modesEntered[lastModeIndex].character === character && propString[i - 1] !== \"\\\\\") {\n        modesEntered.pop();\n        lastModeIndex--;\n      }\n    }\n\n    // If entering/exiting interpolation\n    if (character === \"{\") {\n      modesEntered.push({\n        mode: \"interpolation\",\n        isCalculationEnabled: true\n      });\n      lastModeIndex++;\n    } else if (character === \"}\") {\n      modesEntered.pop();\n      lastModeIndex--;\n    }\n\n    // Check for : outside fn call, string or interpolation. It must be at the\n    // end of a string or have a whitespace between it and following value\n    if (modesEntered[lastModeIndex].mode === \"normal\" && character === \":\") {\n      var propValueStr = propString.substring(i + 1);\n\n      if (propValueStr.length) {\n        var propValue = {\n          before: /^(\\s*)/.exec(propValueStr)[1],\n          value: propValueStr.trim()\n        };\n        // It's a declaration if 1) there is a whitespace after :, or\n        // 2) the value is a number with/without a unit (starts with a number\n        // or a dot), or\n        // 3) the value is a variable (starts with $), or\n        // 4) the value a string, surprisingly\n        if (propValue.before === \"\" && !/^[0-9.$'\"]/.test(propValue.value)) {\n          return null;\n        }\n\n        // +1 for the colon\n        propValue.sourceIndex = propValue.before.length + i + 1;\n        result.propValue = propValue;\n      }\n\n      result.propName = {\n        after: /(\\s*)$/.exec(propName)[1],\n        value: propName.trim()\n      };\n\n      return result;\n    }\n\n    propName += character;\n  }\n\n  return null;\n}","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/parseSelector.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (selector, result, node, cb) {\n  try {\n    (0, _postcssSelectorParser2.default)(cb).process(selector);\n  } catch (e) {\n    result.warn(\"Cannot parse selector\", { node: node });\n  }\n};\n\nvar _postcssSelectorParser = require(\"postcss-selector-parser\");\n\nvar _postcssSelectorParser2 = _interopRequireDefault(_postcssSelectorParser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/sassValueParser/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = findOperators;\nexports.mathOperatorCharType = mathOperatorCharType;\n\n/**\n * Processes a string and finds Sass operators in it\n *\n * @param {Object} args - Named arguments object\n * @param {String} args.string - the input string\n * @param {Number} args.index - the position of args.string from the start of the line\n * @param {Boolean} args.isAfterColon - pass \"true\" if the string is\n *    a variable value, a mixin/function parameter default.\n *    In such cases + and / tend to be operations more often\n * @param {Function} args.callback - will be called on every instance of\n *    an operator. Accepts parameters:\n *    • string - the default source string\n *    • globalIndex - the string's position in the outer input\n *    • startIndex - index in string, where the operator starts\n *    • endIndex - index in string, where the operator ends (for `==`, etc.)\n *\n * @return {Array} array of { symbol, globalIndex, startIndex, endIndex }\n *    for each operator found within a string\n */\nfunction findOperators(_ref) {\n  var string = _ref.string,\n      globalIndex = _ref.globalIndex,\n      isAfterColon = _ref.isAfterColon,\n      callback = _ref.callback;\n\n\n  var mathOperators = [\"+\", \"/\", \"-\", \"*\", \"%\"];\n  // A stack of modes activated for the current char: string, interpolation\n  // Calculations inside strings are not processed, so spaces are not linted\n  var modesEntered = [{\n    mode: \"normal\",\n    isCalculationEnabled: true,\n    character: null\n  }];\n  var result = [];\n  var lastModeIndex = 0;\n\n  for (var i = 0; i < string.length; i++) {\n    var character = string[i];\n    var substringStartingWithIndex = string.substring(i);\n\n    // If entering/exiting a string\n    if (character === \"\\\"\" || character === \"'\") {\n      if (modesEntered[lastModeIndex].isCalculationEnabled === true) {\n        modesEntered.push({\n          mode: \"string\",\n          isCalculationEnabled: false,\n          character: character\n        });\n        lastModeIndex++;\n      } else if (modesEntered[lastModeIndex].mode === \"string\" && modesEntered[lastModeIndex].character === character && string[i - 1] !== \"\\\\\") {\n        modesEntered.pop();\n        lastModeIndex--;\n      }\n    }\n\n    // If entering/exiting interpolation (may be inside a string)\n    // Comparing with length-2 because `#{` at the very end doesnt matter\n    if (character === \"#\" && i + 1 < string.length - 2 && string[i + 1] === \"{\") {\n      modesEntered.push({\n        mode: \"interpolation\",\n        isCalculationEnabled: true\n      });\n      lastModeIndex++;\n    } else if (character === \"}\") {\n      modesEntered.pop();\n      lastModeIndex--;\n    }\n\n    // Don't lint if inside a string\n    if (modesEntered[lastModeIndex].isCalculationEnabled === false) {\n      continue;\n    }\n\n    // If it's a math operator\n    if (mathOperators.indexOf(character) !== -1 && mathOperatorCharType(string, i, isAfterColon) === \"op\" ||\n    // or is \"<\" or \">\"\n    substringStartingWithIndex.search(/^[<>]([^=]|$)/) !== -1) {\n      result.push({\n        symbol: string[i],\n        globalIndex: globalIndex,\n        startIndex: i,\n        endIndex: i\n      });\n      if (callback) {\n        callback(string, globalIndex, i, i);\n      }\n    }\n\n    // \"<=\", \">=\", \"!=\", \"==\"\n    if (substringStartingWithIndex.search(/^[><=!]=/) !== -1) {\n      result.push({\n        symbol: string[i],\n        globalIndex: globalIndex,\n        startIndex: i,\n        endIndex: i + 1\n      });\n      if (callback) {\n        callback(string, globalIndex, i, i + 1);\n      }\n    }\n  }\n  // result.length > 0 && console.log(string, result)\n  return result;\n}\n\n/**\n * Checks if a character is an operator, a sign (+ or -), or part of a string\n *\n * @param {String} string - the source string\n * @param {Number} index - the index of the character in string to check\n * @param {Boolean} isAfterColon - if the value string a variable\n *    value, a mixin/function parameter default. In such cases + and / tend\n *    to be operations more often\n * @return {String|false}\n *    • \"op\", if the character is a operator in a math/string operation\n *    • \"sign\" if it is a + or - before a numeric,\n *    • \"char\" if it is a part of a string,\n *    • false - if it is none from above (most likely an error)\n */\nfunction mathOperatorCharType(string, index, isAfterColon) {\n  // !Checking here to prevent unnecessary calculations and deep recursion\n  // when calling isPrecedingOperator()\n  if ([\"+\", \"/\", \"-\", \"*\", \"%\"].indexOf(string[index]) === -1) {\n    return \"char\";\n  }\n\n  var character = string[index];\n  // console.log(string)\n\n  // ---- Processing + characters\n  if (character === \"+\") {\n    // console.log('checking plus')\n    return checkPlus(string, index, isAfterColon);\n  }\n\n  // ---- Processing - characters\n  if (character === \"-\") {\n    return checkMinus(string, index);\n  }\n\n  // ---- Processing * character\n  if (character === \"*\") {\n    return \"op\";\n  }\n\n  // ---- Processing % character\n  if (character === \"%\") {\n    return checkPercent(string, index);\n  }\n\n  // ---- Processing / character\n  // http://sass-lang.com/documentation/file.SASS_REFERENCE.html#division-and-slash\n  if (character === \"/\") {\n    return checkSlash(string, index, isAfterColon);\n  }\n\n  // console.log(\"nothing applies\")\n  return \"char\";\n}\n\n// --------------------------------------------------------------------------\n// Functions for checking particular characterd (+, -, /)\n// --------------------------------------------------------------------------\n\n/**\n * Checks the specified `+` char type: operator, sign (+ or -), part of string\n *\n * @param {String} string - the source string\n * @param {Number} index - the index of the character in string to check\n * @param {Boolean} isAftercolon - if the value string a variable\n *    value, a mixin/function parameter default. In such cases + is always an\n *    operator if surrounded by numbers/values with units\n * @return {String|false}\n *    • \"op\", if the character is a operator in a math/string operation\n *    • \"sign\" if it is a sign before a positive number,\n *    • false - if it is none from above (most likely an error)\n */\nfunction checkPlus(string, index, isAftercolon) {\n  var before = string.substring(0, index);\n  var after = string.substring(index + 1);\n\n  // If the character is at the beginning of the input\n  var isAtStart_ = isAtStart(string, index);\n  // If the character is at the end of the input\n  var isAtEnd_ = isAtEnd(string, index);\n  var isWhitespaceBefore = before.search(/\\s$/) !== -1;\n  var isWhitespaceAfter = after.search(/^\\s/) !== -1;\n\n  var isValueWithUnitAfter_ = isValueWithUnitAfter(after);\n  var isNumberAfter_ = isNumberAfter(after);\n  var isInterpolationAfter_ = isInterpolationAfter(after);\n  // The early check above helps prevent deep recursion here\n  var isPrecedingOperator_ = isPrecedingOperator(string, index);\n\n  if (isAtStart_) {\n    // console.log(\"+, `+<sth>` or `+ <sth>`\")\n    return \"sign\";\n  }\n\n  // E.g. `1+1`, `string+#fff`\n  if (!isAtStart_ && !isWhitespaceBefore && !isAtEnd_ && !isWhitespaceAfter) {\n    // E.g. `1-+1`\n    if (isPrecedingOperator_) {\n      // console.log('1+1')\n      return \"sign\";\n    }\n    // console.log(\"+, no spaces\")\n    return \"op\";\n  }\n  // e.g. `something +something`\n  if (!isAtEnd_ && !isWhitespaceAfter) {\n    // e.g. `+something`, ` ... , +something`, etc.\n    if (isNoOperandBefore(string, index)) {\n      // console.log(\"+, nothing before\")\n      return \"sign\";\n    }\n\n    // e.g. `sth +10px`, `sth +1`\n    if (isValueWithUnitAfter_.is && !isValueWithUnitAfter_.opsBetween || isNumberAfter_.is && !isNumberAfter_.opsBetween) {\n      if (isAftercolon === true) {\n        // console.log(\": 10px +1\")\n        return \"op\";\n      }\n\n      // e.g. `(sth +10px)`, `fun(sth +1)`\n      if (isInsideParens(string, index) || isInsideFunctionCall(string, index).is) {\n        // console.log(\"+10px or +1, inside function or parens\")\n        return \"op\";\n      }\n\n      // e.g. `#{10px +1}`\n      if (isInsideInterpolation(string, index)) {\n        // console.log('+, #{10px +1}')\n        return \"op\";\n      }\n\n      // console.log('+, default')\n      return \"sign\";\n    }\n\n    // e.g. `sth +#fff`, `sth +string`, `sth +#{...}`, `sth +$var`\n    if (isStringAfter(after) || isHexColorAfter(after) || after[0] === \"$\" || isInterpolationAfter_.is && !isInterpolationAfter_.opsBefore) {\n      // e.g. `sth+ +string`\n      if (isPrecedingOperator_) {\n        // console.log(\"+10px or +1, before is an operator\")\n        return \"sign\";\n      }\n      // console.log(\"+#000, +string, +#{sth}, +$var\")\n      return \"op\";\n    }\n\n    // console.log('sth +sth, default')\n    return \"op\";\n  }\n\n  // If the + is after a value, e.g. `$var+`\n  if (!isAtStart_ && !isWhitespaceBefore) {\n    // It is always an operator. Prior to Sass 4, `#{...}+` was differernt,\n    // but that's not logical and had been fixed.\n    // console.log('1+ sth')\n    return \"op\";\n  }\n\n  // If it has whitespaces on both sides\n  // console.log('sth + sth')\n  return \"op\";\n}\n\n/**\n * Checks the specified `-` character: operator, sign (+ or -), part of string\n *\n * @param {String} string - the source string\n * @param {Number} index - the index of the character in string to check\n * @return {String|false}\n *    • \"op\", if the character is a operator in a math/string operation\n *    • \"sign\" if it is a sign before a negative number,\n *    • \"char\" if it is a part of a string or identifier,\n *    • false - if it is none from above (most likely an error)\n */\nfunction checkMinus(string, index) {\n  var before = string.substring(0, index);\n  var after = string.substring(index + 1);\n  // If the character is at the beginning of the input\n  var isAtStart_ = isAtStart(string, index);\n  // If the character is at the end of the input\n  var isAtEnd_ = isAtEnd(string, index);\n  var isWhitespaceBefore = before.search(/\\s$/) !== -1;\n  var isWhitespaceAfter = after.search(/^\\s/) !== -1;\n\n  var isValueWithUnitAfter_ = isValueWithUnitAfter(after);\n  var isValueWithUnitBefore_ = isValueWithUnitBefore(before);\n  var isNumberAfter_ = isNumberAfter(after);\n  var isNumberBefore_ = isNumberBefore(before);\n  var isInterpolationAfter_ = isInterpolationAfter(after);\n  var isParensAfter_ = isParensAfter(after);\n  var isParensBefore_ = isParensBefore(before);\n  // The early check above helps prevent deep recursion here\n  var isPrecedingOperator_ = isPrecedingOperator(string, index);\n\n  if (isAtStart_) {\n    // console.log(\"-, -<sth> or - <sth>\")\n    return \"sign\";\n  }\n\n  // `10 -    11`\n  if (!isAtEnd_ && !isAtStart_ && isWhitespaceBefore && isWhitespaceAfter) {\n    // console.log(\"-, Op: 10px -  10px\")\n    return \"op\";\n  }\n\n  // e.g. `something -10px`\n  if (!isAtEnd_ && !isAtStart_ && isWhitespaceBefore && !isWhitespaceAfter) {\n    if (isParensAfter_.is && !isParensAfter_.opsBefore) {\n      // console.log(\"-, Op: <sth> -(...)\")\n      return \"op\";\n    }\n\n    // e.g. `sth -1px`, `sth -1`.\n    // Always a sign, even inside parens/function args\n    if (isValueWithUnitAfter_.is && !isValueWithUnitAfter_.opsBetween || isNumberAfter_.is && !isNumberAfter_.opsBetween) {\n      // console.log(\"-, sign: -1px or -1\")\n      return \"sign\";\n    }\n\n    // e.g. `sth --1`, `sth +-2px`\n    if (isValueWithUnitAfter_.is && isValueWithUnitAfter_.opsBetween || isNumberAfter_.is && isNumberAfter_.opsBetween) {\n      // console.log(\"-, op: --1px or --1\")\n      return \"op\";\n    }\n\n    // `<sth> -string`, `<sth> -#{...}`\n    if (isStringAfter(after) || isInterpolationAfter_.is && !isInterpolationAfter_.opsBefore) {\n      // console.log(\"-, char: -#{...}\")\n      return \"char\";\n    }\n\n    // e.g. `#0af -#f0a`, and edge-cases can take a hike\n    if (isHexColorAfter(after) && isHexColorBefore(before.trim())) {\n      // console.log(\"-, op: #fff-, -#fff\")\n      return \"op\";\n    }\n\n    // If the - is before a variable, than it's most likely an operator\n    if (after[0] === \"$\") {\n      if (isPrecedingOperator_) {\n        // console.log(\"-, sign: -$var, another operator before\")\n        return \"sign\";\n      }\n      // console.log(\"-, op: -$var, NO other operator before\")\n      return \"op\";\n    }\n\n    // By default let's make it an sign for now\n    // console.log('-, sign: default in <sth> -<sth>')\n    return \"sign\";\n  }\n\n  // No whitespace before,\n  // e.g. `10x- something`\n  if (!isAtEnd_ && !isAtStart_ && !isWhitespaceBefore && isWhitespaceAfter) {\n    if (isParensBefore_) {\n      // console.log('-, op: `(...)- <sth>`')\n      return \"op\";\n    }\n\n    if (isNumberBefore(before) || isHexColorBefore(before)) {\n      // console.log('`-, op: 10- <sth>, #aff- <sth>`')\n      return \"op\";\n    }\n    // console.log('-, char: default in <sth>- <sth>')\n    return \"char\";\n  }\n\n  // NO Whitespace,\n  // e.g. `10px-1`\n  if (!isAtEnd_ && !isAtStart_ && !isWhitespaceBefore && !isWhitespaceAfter) {\n    // console.log('no spaces')\n    // `<something>-1`, `<something>-10px`\n    if (isValueWithUnitAfter_.is && !isValueWithUnitAfter_.opsBetween || isNumberAfter_.is && !isNumberAfter_.opsBetween) {\n      // `10px-1`, `1-10px`, `1-1`, `1x-1x`\n      if (isValueWithUnitBefore_ || isNumberBefore_) {\n        // console.log(\"-, op: 1-10px\")\n        return \"op\";\n      }\n\n      // The - could be a \"sign\" here, but for now \"char\" does the job\n    }\n    // `1-$var`\n    if (isNumberBefore_ && after[0] === \"$\") {\n      // console.log(\"-, op: 1-$var\")\n      return \"op\";\n    }\n\n    // `fn()-10px`\n    if (isFunctionBefore(before) && (isNumberAfter_.is && !isNumberAfter_.opsBetween || isValueWithUnitAfter_.is && !isValueWithUnitAfter_.opsBetween)) {\n      // console.log(\"-, op: fn()-10px\")\n      return \"op\";\n    }\n  }\n\n  // And in all the other cases it's a characher inside a string\n  // console.log(\"-, default: char\")\n  return \"char\";\n}\n\n/**\n * Checks the specified `/` character: operator, sign (+ or -), part of string\n *\n * @param {String} string - the source string\n * @param {Number} index - the index of the character in string to check\n * @param {Boolean} isAfterColon - if the value string a variable\n *    value, a mixin/function parameter default. In such cases / is always an\n *    operator if surrounded by numbers/values with units\n * @return {String|false}\n *    • \"op\", if the character is a operator in a math/string operation\n *    • \"char\" if it gets compiled as-is, e.g. `font: 10px/1.2;`,\n *    • false - if it is none from above (most likely an error)\n */\nfunction checkSlash(string, index, isAftercolon) {\n  // Trimming these, as spaces before/after a slash don't matter\n  var before = string.substring(0, index).trim();\n  var after = string.substring(index + 1).trim();\n\n  var isValueWithUnitAfter_ = isValueWithUnitAfter(after);\n  var isValueWithUnitBefore_ = isValueWithUnitBefore(before);\n  var isNumberAfter_ = isNumberAfter(after);\n  var isNumberBefore_ = isNumberBefore(before);\n  var isParensAfter_ = isParensAfter(after);\n  var isParensBefore_ = isParensBefore(before);\n\n  // FIRST OFF. Interpolation on any of the sides is a NO-GO for division op\n  if (isInterpolationBefore(before).is || isInterpolationAfter(after).is) {\n    // console.log(\"/, interpolation\")\n    return \"char\";\n  }\n\n  // e.g. `10px/normal`\n  if (isStringBefore(before).is || isStringAfter(after)) {\n    // console.log(\"/, string\")\n    return \"char\";\n  }\n\n  // For all other value options (numbers, value+unit, hex color)\n\n  // `$var/1`, `#fff/-$var`\n  // Here we don't care if there is a sign before the var\n  if (isVariableBefore(before) || isVariableAfter(after).is) {\n    // console.log(\"/, variable\")\n    return \"op\";\n  }\n\n  if (isFunctionBefore(before) || isFunctionAfter(after).is) {\n    // console.log(\"/, function as operand\")\n    return \"op\";\n  }\n\n  if (isParensBefore_ || isParensAfter_.is) {\n    // console.log(\"/, function as operand\")\n    return \"op\";\n  }\n\n  // `$var: 10px/2; // 5px`\n  if (isAftercolon === true && (isValueWithUnitAfter_.is || isNumberAfter_.is) && (isValueWithUnitBefore_ || isNumberBefore_)) {\n    return \"op\";\n  }\n\n  // Quick check of the following operator symbol - if it is a math operator\n  if (\n  // +, *, % count as operators unless after interpolation or at the start\n  before.search(/[^{,(}\\s]\\s*[+*%]\\s*[^(){},]+$/) !== -1 ||\n  // We consider minus as op only if surrounded by whitespaces (` - `);\n  before.search(/[^{,(}\\s]\\s+-\\s+[^(){},]+$/) !== -1 ||\n\n  // `10/2 * 3`, `10/2 % 3`, with or without spaces\n  after.search(/^[^(){},]+[*%]/) !== -1 ||\n  // `10px/2px+1`, `10px/2px+ 1`\n  after.search(/^[^(){},\\s]+[+]/) !== -1 ||\n  // Anything but `10px/2px +1`, `10px/2px +1px`\n  after.search(/^[^(){},\\s]+\\s+(\\+\\D)/) !== -1 ||\n  // Following ` -`: only if `$var` after (`10/10 -$var`)\n  after.search(/^[^(){},\\s]+\\s+-(\\$|\\s)/) !== -1 ||\n  // Following `-`: only if number after (`10s/10s-10`, `10s/10s-.1`)\n  after.search(/^[^(){},\\s]+-(\\.){0,1}\\d/) !== -1 ||\n  // Or if there is a number before anything but string after (not `10s/1-str`,)\n  after.search(/^(\\d*\\.){0,1}\\d+-\\s*[^#a-zA-Z_\\s]/) !== -1) {\n    // console.log(\"/, math op around\")\n    return \"op\";\n  }\n\n  // e.g. `(1px/1)`, `fn(7 / 15)`, but not `url(8/11)`\n  var isInsideFn = isInsideFunctionCall(string, index);\n  if (isInsideParens(string, index) || isInsideFn.is && isInsideFn.fn !== \"url\") {\n    // console.log(\"/, parens or function arg\")\n    return \"op\";\n  }\n\n  // console.log(\"/, default\")\n  return \"char\";\n}\n\n/**\n * Checks the specified `%` character: operator or part of value\n *\n * @param {String} string - the source string\n * @param {Number} index - the index of the character in string to check\n * @return {String|false}\n *    • \"op\", if the character is a operator in a math/string operation\n *    • \"char\" if it gets compiled as-is, e.g. `width: 10%`,\n *    • false - if it is none from above (most likely an error)\n */\nfunction checkPercent(string, index) {\n  // Trimming these, as spaces before/after a slash don't matter\n  var before = string.substring(0, index);\n  var after = string.substring(index + 1);\n\n  // If the character is at the beginning of the input\n  var isAtStart_ = isAtStart(string, index);\n  // If the character is at the end of the input\n  var isAtEnd_ = isAtEnd(string, index);\n  var isWhitespaceBefore = before.search(/\\s$/) !== -1;\n  var isWhitespaceAfter = after.search(/^\\s/) !== -1;\n\n  var isParensBefore_ = isParensBefore(before);\n\n  // FIRST OFF. Interpolation on any of the sides is a NO-GO\n  if (isInterpolationBefore(before.trim()).is || isInterpolationAfter(after.trim()).is) {\n    // console.log(\"%, interpolation\")\n    return \"char\";\n  }\n\n  if (isAtStart_ || isAtEnd_) {\n    // console.log(\"%, start/end\")\n    return \"char\";\n  }\n\n  // In `<sth> %<sth>` it's most likely an operator (except for inteprolation\n  // checked above)\n  if (isWhitespaceBefore && !isWhitespaceAfter) {\n    // console.log(\"%, `<sth> %<sth>`\")\n    return \"op\";\n  }\n\n  // `$var% 1`, `$var%1`, `$var%-1`\n  if (isVariableBefore(before) || isParensBefore_) {\n    // console.log(\"%, after a variable, function or parens\")\n    return \"op\";\n  }\n\n  // in all other cases in `<sth>% <sth>` it is most likely a unit\n  if (!isWhitespaceBefore && isWhitespaceAfter) {\n    // console.log(\"%, `<sth>% <sth>`\")\n    return \"char\";\n  }\n\n  // console.log(\"%, default\")\n  return \"char\";\n}\n\n// --------------------------------------------------------------------------\n// Lots of elementary helpers\n// --------------------------------------------------------------------------\n\nfunction isAtStart(string, index) {\n  var before = string.substring(0, index).trim();\n  return before.length === 0 || before.search(/[({,]$/) !== -1;\n}\n\nfunction isAtEnd(string, index) {\n  var after = string.substring(index + 1).trim();\n  return after.length === 0 || after.search(/^[,)}]/) !== -1;\n}\n\nfunction isInsideParens(string, index) {\n  var before = string.substring(0, index).trim();\n  var after = string.substring(index + 1).trim();\n\n  if (before.search(/(?:^|[,{]|\\s)\\(\\s*[^(){},]+$/) !== -1 && after.search(/^[^(){},\\s]+\\s*\\)/) !== -1) {\n    return true;\n  }\n  return false;\n}\n\nfunction isInsideInterpolation(string, index) {\n  var before = string.substring(0, index).trim();\n\n  if (before.search(/#\\{[^}]*$/) !== -1) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Checks if the character is inside a function agruments\n *\n * @param {String} string - the input string\n * @param {Number} index - current character index\n * @return {Object} return\n *    {Boolean} return.is - if inside a function arguments\n *    {String} return.fn - function name\n */\nfunction isInsideFunctionCall(string, index) {\n  var result = { is: false, fn: null };\n  var before = string.substring(0, index).trim();\n  var after = string.substring(index + 1).trim();\n  var beforeMatch = before.match(/([a-zA-Z_-][a-zA-Z0-9_-]*)\\([^(){},]+$/);\n\n  if (beforeMatch && beforeMatch[0] && after.search(/^[^({},]+\\)/) !== -1) {\n    result.is = true;\n    result.fn = beforeMatch[1];\n  }\n\n  return result;\n}\n\n/**\n * Checks if there is a string before the character.\n * Also checks if there is a math operator in between\n *\n * @param {String} before - the input string that preceses the character\n * @return {Object} return\n *    {Boolean} return.is - if there is a string\n *    {String} return.opsBetween - if there are operators in between\n */\nfunction isStringBefore(before) {\n  var result = { is: false, opsBetween: false };\n  var stringOpsClipped = before.replace(/(\\s*[+/*%]|\\s+-)+$/, \"\");\n\n  if (stringOpsClipped !== before) {\n    result.opsBetween = true;\n  }\n  // If it is quoted\n  if (stringOpsClipped[stringOpsClipped.length - 1] == \"\\\"\" || stringOpsClipped[stringOpsClipped.length - 1] == \"'\") {\n    result.is = true;\n  } else if (stringOpsClipped.search(/(?:^|[/(){},: ])([a-zA-Z_][a-zA-Z_0-9-]*|-+[a-zA-Z_]+[a-zA-Z_0-9-]*)$/) !== -1) {\n    // First pattern: a1, a1a, a-1, \n    result.is = true;\n  }\n\n  return result;\n}\n\nfunction isStringAfter(after) {\n  var stringTrimmed = after.trim();\n\n  // If it is quoted\n  if (stringTrimmed[0] == \"\\\"\" || stringTrimmed[0] == \"'\") return true;\n\n  // e.g. `a1`, `a1a`, `a-1`, and even `--s323` \n  if (stringTrimmed.search(/^([a-zA-Z_][a-zA-Z_0-9-]*|-+[a-zA-Z_]+[a-zA-Z_0-9-]*)(?:$|[)}, ])/) !== -1) return true;\n\n  return false;\n}\n\nfunction isInterpolationAfter(after) {\n  var result = { is: false, opsBetween: false };\n  var matches = after.match(/^\\s*([+/*%-]\\s*)*#{/);\n  if (matches) {\n    if (matches[0]) {\n      result.is = true;\n    }\n    if (matches[1]) {\n      result.opsBetween = true;\n    }\n  }\n  return result;\n}\n\nfunction isParensAfter(after) {\n  var result = { is: false, opsBetween: false };\n  var matches = after.match(/^\\s*([+/*%-]\\s*)*\\(/);\n  if (matches) {\n    if (matches[0]) {\n      result.is = true;\n    }\n    if (matches[1]) {\n      result.opsBetween = true;\n    }\n  }\n  return result;\n}\n\nfunction isParensBefore(before) {\n  return before.search(/\\)\\s*$/) !== -1;\n}\n\n/**\n * Checks if there is an interpolation before the character.\n * Also checks if there is a math operator in between\n *\n * @param {String} before - the input string that preceses the character\n * @return {Object} return\n *    {Boolean} return.is - if there is an interpolation\n *    {String} return.opsBetween - if there are operators in between\n */\nfunction isInterpolationBefore(before) {\n  var result = { is: false, opsBetween: false };\n  // Removing preceding operators if any\n  var beforeOpsClipped = before.replace(/(\\s*[+/*%-])+$/, \"\");\n  if (beforeOpsClipped !== before) {\n    result.opsBetween = true;\n  }\n  if (beforeOpsClipped[beforeOpsClipped.length - 1] === \"}\") {\n    result.is = true;\n  }\n  return result;\n}\n\nfunction isValueWithUnitBefore(before) {\n  // 1px, 0.1p-x, .2p-, 11.2pdf-df1df_\n  // Surprisingly, ` d.10px` - .10px is separated from a sequence\n  // and is considered a value with a unit\n  if (before.trim().search(/(^|[/(, ]|\\.)\\d[a-zA-Z_0-9-]+$/) !== -1) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isValueWithUnitAfter(after) {\n  var result = { is: false, opsBetween: false };\n  // 1px, 0.1p-x, .2p-, 11.2pdf-dfd1f_\n  // Again, ` d.10px` - .10px is separated from a sequence\n  // and is considered a value with a unit\n  var matches = after.match(/^\\s*([+/*%-]\\s*)*(\\d+(\\.\\d+){0,1}|\\.\\d+)[a-zA-Z_0-9-]+(?:$|[)}, ])/);\n  if (matches) {\n    if (matches[0]) {\n      result.is = true;\n    }\n    if (matches[1]) {\n      result.opsBetween = true;\n    }\n  }\n  return result;\n}\n\nfunction isNumberAfter(after) {\n  var result = { is: false, opsBetween: false };\n  var matches = after.match(/^\\s*([+/*%-]\\s*)*(\\d+(\\.\\d+){0,1}|\\.\\d+)(?:$|[)}, ])/);\n  if (matches) {\n    if (matches[0]) {\n      result.is = true;\n    }\n    if (matches[1]) {\n      result.opsBetween = true;\n    }\n  }\n  return result;\n}\n\nfunction isNumberBefore(before) {\n  if (before.trim().search(/(?:^|[/(){},\\s])(\\d+(\\.\\d+){0,1}|\\.\\d+)$/) !== -1) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isVariableBefore(before) {\n  return before.trim().search(/\\$[a-zA-Z_0-9-]+$/) !== -1;\n}\n\nfunction isVariableAfter(after) {\n  var result = { is: false, opsBetween: false };\n  var matches = after.match(/^\\s*([+/*%-]\\s*)*\\$/);\n  if (matches) {\n    if (matches[0]) {\n      result.is = true;\n    }\n    if (matches[1]) {\n      result.opsBetween = true;\n    }\n  }\n  return result;\n}\n\nfunction isFunctionBefore(before) {\n  return before.trim().search(/[a-zA-Z0-9_-]\\(.*?\\)\\s*$/) !== -1;\n}\n\nfunction isFunctionAfter(after) {\n  var result = { is: false, opsBetween: false };\n  // `-fn()` is a valid function name, so if a - should be a sign/operator,\n  // it must have a space after\n  var matches = after.match(/^\\s*(-\\s+|[+/*%]\\s*)*[a-zA_Z_-][a-zA-Z_0-9-]*\\(/);\n  if (matches) {\n    if (matches[0]) {\n      result.is = true;\n    }\n    if (matches[1]) {\n      result.opsBetween = true;\n    }\n  }\n  return result;\n}\n\n/**\n * Checks if the input string is a hex color value\n *\n * @param {String} string - the input\n * @return {Boolean} true, if the input is a hex color\n */\nfunction isHexColor(string) {\n  return string.trim().search(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/) !== -1;\n}\n\nfunction isHexColorAfter(after) {\n  var afterTrimmed = after.match(/(.*?)(?:[)},+/*%-]|\\s|$)/)[1].trim();\n  return isHexColor(afterTrimmed);\n}\n\nfunction isHexColorBefore(before) {\n  if (before.search(/(?:[/(){},+/*%-\\s]|^)#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/) !== -1) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Checks if there is no operand before the currenc char\n * In other words, the current char is at the start of a possible operation,\n * e.g. at the string start, after the opening paren or after a comma\n *\n * @param {String} string - the input string\n * @param {Number} index - current char's position in string\n * @return {Boolean}\n */\nfunction isNoOperandBefore(string, index) {\n  var before = string.substring(0, index).trim();\n  return before.length === 0 || before.search(/[({,]&/) !== -1;\n}\n\nfunction isPrecedingOperator(string, index) {\n  var prevCharIndex = -1;\n  for (var i = index - 1; i >= 0; i--) {\n    if (string[i].search(/\\s/) === -1) {\n      prevCharIndex = i;\n      break;\n    }\n  }\n\n  if (prevCharIndex === -1) {\n    return false;\n  }\n\n  if (mathOperatorCharType(string, prevCharIndex) === \"op\") {\n    return true;\n  }\n\n  return false;\n}","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/whitespaceChecker.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (targetWhitespace, expectation, messages) {\n\n  // Keep track of active arguments in order to avoid passing\n  // too much stuff around, making signatures long and confusing.\n  // This variable gets reset anytime a checking function is called.\n  var activeArgs = void 0;\n\n  /**\n   * Check for whitespace *before* a character.\n   *\n   * @param {object} args - Named arguments object\n   * @param {string} args.source - The source string\n   * @param {number} args.index - The index of the character to check before\n   * @param {function} args.err - If a violation is found, this callback\n   *   will be invoked with the relevant warning message.\n   *   Typically this callback will report() the violation.\n   * @param {function} args.errTarget - If a violation is found, this string\n   *   will be sent to the relevant warning message.\n   * @param {string} [args.lineCheckStr] - Single- and multi-line checkers\n   *   will use this string to determine whether they should proceed,\n   *   i.e. if this string is one line only, single-line checkers will check,\n   *   multi-line checkers will ignore.\n   *   If none is passed, they will use `source`.\n   * @param {boolean} [args.onlyOneChar=false] - Only check *one* character before.\n   *   By default, \"always-*\" checks will look for the `targetWhitespace` one\n   *   before and then ensure there is no whitespace two before. This option\n   *   bypasses that second check.\n   * @param {boolean} [args.allowIndentation=false] - Allow arbitrary indentation\n   *   between the `targetWhitespace` (almost definitely a newline) and the `index`.\n   *   With this option, the checker will see if a newline *begins* the whitespace before\n   *   the `index`.\n   */\n  function before(_ref) {\n    var source = _ref.source,\n        index = _ref.index,\n        err = _ref.err,\n        errTarget = _ref.errTarget,\n        lineCheckStr = _ref.lineCheckStr,\n        _ref$onlyOneChar = _ref.onlyOneChar,\n        onlyOneChar = _ref$onlyOneChar === undefined ? false : _ref$onlyOneChar,\n        _ref$allowIndentation = _ref.allowIndentation,\n        allowIndentation = _ref$allowIndentation === undefined ? false : _ref$allowIndentation;\n\n    activeArgs = { source: source, index: index, err: err, errTarget: errTarget, onlyOneChar: onlyOneChar, allowIndentation: allowIndentation };\n    switch (expectation) {\n      case \"always\":\n        expectBefore();\n        break;\n      case \"never\":\n        rejectBefore();\n        break;\n      case \"always-single-line\":\n        if (!(0, _isSingleLineString2.default)(lineCheckStr || source)) {\n          return;\n        }\n        expectBefore(messages.expectedBeforeSingleLine);\n        break;\n      case \"never-single-line\":\n        if (!(0, _isSingleLineString2.default)(lineCheckStr || source)) {\n          return;\n        }\n        rejectBefore(messages.rejectedBeforeSingleLine);\n        break;\n      case \"always-multi-line\":\n        if ((0, _isSingleLineString2.default)(lineCheckStr || source)) {\n          return;\n        }\n        expectBefore(messages.expectedBeforeMultiLine);\n        break;\n      case \"never-multi-line\":\n        if ((0, _isSingleLineString2.default)(lineCheckStr || source)) {\n          return;\n        }\n        rejectBefore(messages.rejectedBeforeMultiLine);\n        break;\n      default:\n        throw (0, _configurationError2.default)(\"Unknown expectation \\\"\" + expectation + \"\\\"\");\n    }\n  }\n\n  /**\n   * Check for whitespace *after* a character.\n   *\n   * Parameters are pretty much the same as for `before()`, above, just substitute\n   * the word \"after\" for \"before\".\n   */\n  function after(_ref2) {\n    var source = _ref2.source,\n        index = _ref2.index,\n        err = _ref2.err,\n        errTarget = _ref2.errTarget,\n        lineCheckStr = _ref2.lineCheckStr,\n        _ref2$onlyOneChar = _ref2.onlyOneChar,\n        onlyOneChar = _ref2$onlyOneChar === undefined ? false : _ref2$onlyOneChar;\n\n    activeArgs = { source: source, index: index, err: err, errTarget: errTarget, onlyOneChar: onlyOneChar };\n    switch (expectation) {\n      case \"always\":\n        expectAfter();\n        break;\n      case \"never\":\n        rejectAfter();\n        break;\n      case \"always-single-line\":\n        if (!(0, _isSingleLineString2.default)(lineCheckStr || source)) {\n          return;\n        }\n        expectAfter(messages.expectedAfterSingleLine);\n        break;\n      case \"never-single-line\":\n        if (!(0, _isSingleLineString2.default)(lineCheckStr || source)) {\n          return;\n        }\n        rejectAfter(messages.rejectedAfterSingleLine);\n        break;\n      case \"always-multi-line\":\n        if ((0, _isSingleLineString2.default)(lineCheckStr || source)) {\n          return;\n        }\n        expectAfter(messages.expectedAfterMultiLine);\n        break;\n      case \"never-multi-line\":\n        if ((0, _isSingleLineString2.default)(lineCheckStr || source)) {\n          return;\n        }\n        rejectAfter(messages.rejectedAfterMultiLine);\n        break;\n      default:\n        throw (0, _configurationError2.default)(\"Unknown expectation \\\"\" + expectation + \"\\\"\");\n    }\n  }\n\n  function beforeAllowingIndentation(obj) {\n    before((0, _lodash.assign)({}, obj, { allowIndentation: true }));\n  }\n\n  function expectBefore() {\n    var messageFunc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : messages.expectedBefore;\n\n    if (activeArgs.allowIndentation) {\n      expectBeforeAllowingIndentation(messageFunc);\n      return;\n    }\n\n    var _activeArgs = activeArgs,\n        source = _activeArgs.source,\n        index = _activeArgs.index;\n\n    var oneCharBefore = source[index - 1];\n    var twoCharsBefore = source[index - 2];\n\n    if (!isValue(oneCharBefore)) {\n      return;\n    }\n\n    if (targetWhitespace === \"newline\") {\n      // If index is preceeded by a Windows CR-LF ...\n      if (oneCharBefore === \"\\n\" && twoCharsBefore === \"\\r\") {\n        if (activeArgs.onlyOneChar || !(0, _isWhitespace2.default)(source[index - 3])) {\n          return;\n        }\n      }\n\n      // If index is followed by a Unix LF ...\n      if (oneCharBefore === \"\\n\" && twoCharsBefore !== \"\\r\") {\n        if (activeArgs.onlyOneChar || !(0, _isWhitespace2.default)(twoCharsBefore)) {\n          return;\n        }\n      }\n    }\n\n    if (targetWhitespace === \"space\" && oneCharBefore === \" \") {\n      if (activeArgs.onlyOneChar || !(0, _isWhitespace2.default)(twoCharsBefore)) {\n        return;\n      }\n    }\n\n    activeArgs.err(messageFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));\n  }\n\n  function expectBeforeAllowingIndentation() {\n    var messageFunc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : messages.expectedBefore;\n    var _activeArgs2 = activeArgs,\n        source = _activeArgs2.source,\n        index = _activeArgs2.index,\n        err = _activeArgs2.err;\n\n    var expectedChar = function () {\n      if (targetWhitespace === \"newline\") {\n        return \"\\n\";\n      }\n      if (targetWhitespace === \"space\") {\n        return \" \";\n      }\n    }();\n    var i = index - 1;\n    while (source[i] !== expectedChar) {\n      if (source[i] === \"\\t\" || source[i] === \" \") {\n        i--;\n        continue;\n      }\n      err(messageFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));\n      return;\n    }\n  }\n\n  function rejectBefore() {\n    var messageFunc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : messages.rejectedBefore;\n    var _activeArgs3 = activeArgs,\n        source = _activeArgs3.source,\n        index = _activeArgs3.index;\n\n    var oneCharBefore = source[index - 1];\n\n    if (isValue(oneCharBefore) && (0, _isWhitespace2.default)(oneCharBefore)) {\n      activeArgs.err(messageFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));\n    }\n  }\n\n  function afterOneOnly(obj) {\n    after((0, _lodash.assign)({}, obj, { onlyOneChar: true }));\n  }\n\n  function expectAfter() {\n    var messageFunc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : messages.expectedAfter;\n    var _activeArgs4 = activeArgs,\n        source = _activeArgs4.source,\n        index = _activeArgs4.index;\n\n\n    var oneCharAfter = index + 1 < source.length ? source[index + 1] : \"\";\n    var twoCharsAfter = index + 2 < source.length ? source[index + 2] : \"\";\n\n    if (!isValue(oneCharAfter)) {\n      return;\n    }\n\n    if (targetWhitespace === \"newline\") {\n      // If index is followed by a Windows CR-LF ...\n      if (oneCharAfter === \"\\r\" && twoCharsAfter === \"\\n\") {\n        var threeCharsAfter = index + 3 < source.length ? source[index + 3] : \"\";\n\n        if (activeArgs.onlyOneChar || !(0, _isWhitespace2.default)(threeCharsAfter)) {\n          return;\n        }\n      }\n\n      // If index is followed by a Unix LF ...\n      if (oneCharAfter === \"\\n\") {\n        if (activeArgs.onlyOneChar || !(0, _isWhitespace2.default)(twoCharsAfter)) {\n          return;\n        }\n      }\n    }\n\n    if (targetWhitespace === \"space\" && oneCharAfter === \" \") {\n      if (activeArgs.onlyOneChar || !(0, _isWhitespace2.default)(twoCharsAfter)) {\n        return;\n      }\n    }\n\n    activeArgs.err(messageFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));\n  }\n\n  function rejectAfter() {\n    var messageFunc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : messages.rejectedAfter;\n    var _activeArgs5 = activeArgs,\n        source = _activeArgs5.source,\n        index = _activeArgs5.index;\n\n    var oneCharAfter = index + 1 < source.length ? source[index + 1] : \"\";\n\n    if (isValue(oneCharAfter) && (0, _isWhitespace2.default)(oneCharAfter)) {\n      activeArgs.err(messageFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));\n    }\n  }\n\n  return {\n    before: before,\n    beforeAllowingIndentation: beforeAllowingIndentation,\n    after: after,\n    afterOneOnly: afterOneOnly\n  };\n};\n\nvar _lodash = require(\"lodash\");\n\nvar _isWhitespace = require(\"./isWhitespace\");\n\nvar _isWhitespace2 = _interopRequireDefault(_isWhitespace);\n\nvar _isSingleLineString = require(\"./isSingleLineString\");\n\nvar _isSingleLineString2 = _interopRequireDefault(_isSingleLineString);\n\nvar _configurationError = require(\"./configurationError\");\n\nvar _configurationError2 = _interopRequireDefault(_configurationError);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isValue(x) {\n  return x !== undefined && x !== null;\n}\n\n/**\n * Create a whitespaceChecker, which exposes the following functions:\n * - `before()`\n * - `beforeAllowingIndentation()`\n * - `after()`\n * - `afterOneOnly()`\n *\n * @param {\"space\"|\"newline\"} targetWhitespace - This is a keyword instead\n *   of the actual character (e.g. \" \") in order to accommodate\n *   different styles of newline (\"\\n\" vs \"\\r\\n\")\n * @param {\n *     \"always\"|\"never\"\n *     |\"always-single-line\"|\"always-multi-line\"\n *     | \"never-single-line\"|\"never-multi-line\"\n *   } expectation\n * @param {object} messages - An object of message functions;\n *   calling `before*()` or `after*()` and the `expectation` that is passed\n *   determines which message functions are required\n * @param {function} [messages.exectedBefore]\n * @param {function} [messages.rejectedBefore]\n * @param {function} [messages.expectedAfter]\n * @param {function} [messages.rejectedAfter]\n * @param {function} [messages.expectedBeforeSingleLine]\n * @param {function} [messages.rejectedBeforeSingleLine]\n * @param {function} [messages.expectedBeforeMultiLine]\n * @param {function} [messages.rejectedBeforeMultiLine]\n * @return {object} The checker, with its exposed checking functions\n */","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/utils/configurationError.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (text) {\n  var err = new Error(text);\n  err.code = 78;\n  return err;\n};","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _atExtendNoMissingPlaceholder = require(\"./at-extend-no-missing-placeholder\");\n\nvar _atExtendNoMissingPlaceholder2 = _interopRequireDefault(_atExtendNoMissingPlaceholder);\n\nvar _atElseClosingBraceNewlineAfter = require(\"./at-else-closing-brace-newline-after\");\n\nvar _atElseClosingBraceNewlineAfter2 = _interopRequireDefault(_atElseClosingBraceNewlineAfter);\n\nvar _atElseClosingBraceSpaceAfter = require(\"./at-else-closing-brace-space-after\");\n\nvar _atElseClosingBraceSpaceAfter2 = _interopRequireDefault(_atElseClosingBraceSpaceAfter);\n\nvar _atElseEmptyLineBefore = require(\"./at-else-empty-line-before\");\n\nvar _atElseEmptyLineBefore2 = _interopRequireDefault(_atElseEmptyLineBefore);\n\nvar _atFunctionPattern = require(\"./at-function-pattern\");\n\nvar _atFunctionPattern2 = _interopRequireDefault(_atFunctionPattern);\n\nvar _atIfClosingBraceNewlineAfter = require(\"./at-if-closing-brace-newline-after\");\n\nvar _atIfClosingBraceNewlineAfter2 = _interopRequireDefault(_atIfClosingBraceNewlineAfter);\n\nvar _atIfClosingBraceSpaceAfter = require(\"./at-if-closing-brace-space-after\");\n\nvar _atIfClosingBraceSpaceAfter2 = _interopRequireDefault(_atIfClosingBraceSpaceAfter);\n\nvar _atImportNoPartialExtension = require(\"./at-import-no-partial-extension\");\n\nvar _atImportNoPartialExtension2 = _interopRequireDefault(_atImportNoPartialExtension);\n\nvar _atImportNoPartialLeadingUnderscore = require(\"./at-import-no-partial-leading-underscore\");\n\nvar _atImportNoPartialLeadingUnderscore2 = _interopRequireDefault(_atImportNoPartialLeadingUnderscore);\n\nvar _atImportPartialExtensionBlacklist = require(\"./at-import-partial-extension-blacklist\");\n\nvar _atImportPartialExtensionBlacklist2 = _interopRequireDefault(_atImportPartialExtensionBlacklist);\n\nvar _atImportPartialExtensionWhitelist = require(\"./at-import-partial-extension-whitelist\");\n\nvar _atImportPartialExtensionWhitelist2 = _interopRequireDefault(_atImportPartialExtensionWhitelist);\n\nvar _atMixinArgumentlessCallParentheses = require(\"./at-mixin-argumentless-call-parentheses\");\n\nvar _atMixinArgumentlessCallParentheses2 = _interopRequireDefault(_atMixinArgumentlessCallParentheses);\n\nvar _atMixinNoArgumentlessCallParentheses = require(\"./at-mixin-no-argumentless-call-parentheses\");\n\nvar _atMixinNoArgumentlessCallParentheses2 = _interopRequireDefault(_atMixinNoArgumentlessCallParentheses);\n\nvar _atMixinPattern = require(\"./at-mixin-pattern\");\n\nvar _atMixinPattern2 = _interopRequireDefault(_atMixinPattern);\n\nvar _declarationNestedProperties = require(\"./declaration-nested-properties\");\n\nvar _declarationNestedProperties2 = _interopRequireDefault(_declarationNestedProperties);\n\nvar _declarationNestedPropertiesNoDividedGroups = require(\"./declaration-nested-properties-no-divided-groups\");\n\nvar _declarationNestedPropertiesNoDividedGroups2 = _interopRequireDefault(_declarationNestedPropertiesNoDividedGroups);\n\nvar _dollarVariableColonNewlineAfter = require(\"./dollar-variable-colon-newline-after\");\n\nvar _dollarVariableColonNewlineAfter2 = _interopRequireDefault(_dollarVariableColonNewlineAfter);\n\nvar _dollarVariableColonSpaceAfter = require(\"./dollar-variable-colon-space-after\");\n\nvar _dollarVariableColonSpaceAfter2 = _interopRequireDefault(_dollarVariableColonSpaceAfter);\n\nvar _dollarVariableColonSpaceBefore = require(\"./dollar-variable-colon-space-before\");\n\nvar _dollarVariableColonSpaceBefore2 = _interopRequireDefault(_dollarVariableColonSpaceBefore);\n\nvar _dollarVariableEmptyLineBefore = require(\"./dollar-variable-empty-line-before\");\n\nvar _dollarVariableEmptyLineBefore2 = _interopRequireDefault(_dollarVariableEmptyLineBefore);\n\nvar _dollarVariableNoMissingInterpolation = require(\"./dollar-variable-no-missing-interpolation\");\n\nvar _dollarVariableNoMissingInterpolation2 = _interopRequireDefault(_dollarVariableNoMissingInterpolation);\n\nvar _dollarVariablePattern = require(\"./dollar-variable-pattern\");\n\nvar _dollarVariablePattern2 = _interopRequireDefault(_dollarVariablePattern);\n\nvar _doubleSlashCommentEmptyLineBefore = require(\"./double-slash-comment-empty-line-before\");\n\nvar _doubleSlashCommentEmptyLineBefore2 = _interopRequireDefault(_doubleSlashCommentEmptyLineBefore);\n\nvar _doubleSlashCommentInline = require(\"./double-slash-comment-inline\");\n\nvar _doubleSlashCommentInline2 = _interopRequireDefault(_doubleSlashCommentInline);\n\nvar _doubleSlashCommentWhitespaceInside = require(\"./double-slash-comment-whitespace-inside\");\n\nvar _doubleSlashCommentWhitespaceInside2 = _interopRequireDefault(_doubleSlashCommentWhitespaceInside);\n\nvar _mediaFeatureValueDollarVariable = require(\"./media-feature-value-dollar-variable\");\n\nvar _mediaFeatureValueDollarVariable2 = _interopRequireDefault(_mediaFeatureValueDollarVariable);\n\nvar _operatorNoNewlineAfter = require(\"./operator-no-newline-after\");\n\nvar _operatorNoNewlineAfter2 = _interopRequireDefault(_operatorNoNewlineAfter);\n\nvar _operatorNoNewlineBefore = require(\"./operator-no-newline-before\");\n\nvar _operatorNoNewlineBefore2 = _interopRequireDefault(_operatorNoNewlineBefore);\n\nvar _operatorNoUnspaced = require(\"./operator-no-unspaced\");\n\nvar _operatorNoUnspaced2 = _interopRequireDefault(_operatorNoUnspaced);\n\nvar _partialNoImport = require(\"./partial-no-import\");\n\nvar _partialNoImport2 = _interopRequireDefault(_partialNoImport);\n\nvar _percentPlaceholderPattern = require(\"./percent-placeholder-pattern\");\n\nvar _percentPlaceholderPattern2 = _interopRequireDefault(_percentPlaceholderPattern);\n\nvar _selectorNoRedundantNestingSelector = require(\"./selector-no-redundant-nesting-selector\");\n\nvar _selectorNoRedundantNestingSelector2 = _interopRequireDefault(_selectorNoRedundantNestingSelector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n  \"at-extend-no-missing-placeholder\": _atExtendNoMissingPlaceholder2.default,\n  \"at-else-closing-brace-newline-after\": _atElseClosingBraceNewlineAfter2.default,\n  \"at-else-closing-brace-space-after\": _atElseClosingBraceSpaceAfter2.default,\n  \"at-else-empty-line-before\": _atElseEmptyLineBefore2.default,\n  \"at-function-pattern\": _atFunctionPattern2.default,\n  \"at-if-closing-brace-newline-after\": _atIfClosingBraceNewlineAfter2.default,\n  \"at-if-closing-brace-space-after\": _atIfClosingBraceSpaceAfter2.default,\n  \"at-import-no-partial-extension\": _atImportNoPartialExtension2.default,\n  \"at-import-no-partial-leading-underscore\": _atImportNoPartialLeadingUnderscore2.default,\n  \"at-import-partial-extension-blacklist\": _atImportPartialExtensionBlacklist2.default,\n  \"at-import-partial-extension-whitelist\": _atImportPartialExtensionWhitelist2.default,\n  \"at-mixin-argumentless-call-parentheses\": _atMixinArgumentlessCallParentheses2.default,\n  \"at-mixin-no-argumentless-call-parentheses\": _atMixinNoArgumentlessCallParentheses2.default,\n  \"at-mixin-pattern\": _atMixinPattern2.default,\n  \"declaration-nested-properties\": _declarationNestedProperties2.default,\n  \"declaration-nested-properties-no-divided-groups\": _declarationNestedPropertiesNoDividedGroups2.default,\n  \"dollar-variable-colon-newline-after\": _dollarVariableColonNewlineAfter2.default,\n  \"dollar-variable-colon-space-after\": _dollarVariableColonSpaceAfter2.default,\n  \"dollar-variable-colon-space-before\": _dollarVariableColonSpaceBefore2.default,\n  \"dollar-variable-empty-line-before\": _dollarVariableEmptyLineBefore2.default,\n  \"dollar-variable-no-missing-interpolation\": _dollarVariableNoMissingInterpolation2.default,\n  \"dollar-variable-pattern\": _dollarVariablePattern2.default,\n  \"double-slash-comment-empty-line-before\": _doubleSlashCommentEmptyLineBefore2.default,\n  \"double-slash-comment-inline\": _doubleSlashCommentInline2.default,\n  \"double-slash-comment-whitespace-inside\": _doubleSlashCommentWhitespaceInside2.default,\n  \"media-feature-value-dollar-variable\": _mediaFeatureValueDollarVariable2.default,\n  \"operator-no-newline-after\": _operatorNoNewlineAfter2.default,\n  \"operator-no-newline-before\": _operatorNoNewlineBefore2.default,\n  \"operator-no-unspaced\": _operatorNoUnspaced2.default,\n  \"percent-placeholder-pattern\": _percentPlaceholderPattern2.default,\n  \"partial-no-import\": _partialNoImport2.default,\n  \"selector-no-redundant-nesting-selector\": _selectorNoRedundantNestingSelector2.default\n};","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/at-extend-no-missing-placeholder/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (actual) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, { actual: actual });\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkAtRules(\"extend\", function (atrule) {\n      var isPlaceholder = atrule.params.trim()[0] === \"%\";\n      var isInterpolation = /^#{.+}/.test(atrule.params.trim());\n\n      if (!isPlaceholder && !isInterpolation) {\n        _stylelint.utils.report({\n          ruleName: ruleName,\n          result: result,\n          node: atrule,\n          message: messages.rejected\n        });\n      }\n    });\n  };\n};\n\nvar _stylelint = require(\"stylelint\");\n\nvar _utils = require(\"../../utils\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"at-extend-no-missing-placeholder\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  rejected: \"Expected a placeholder selector (e.g. %placeholder) to be used in @extend\"\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/at-else-closing-brace-newline-after/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (expectation) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\"always-last-in-chain\"]\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    (0, _atIfClosingBraceNewlineAfter.sassConditionalBraceNLAfterChecker)({ root: root, result: result, ruleName: ruleName, atRuleName: \"else\", expectation: expectation, messages: messages });\n  };\n};\n\nvar _utils = require(\"../../utils\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar _atIfClosingBraceNewlineAfter = require(\"../at-if-closing-brace-newline-after\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"at-else-closing-brace-newline-after\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expected: \"Expected newline after \\\"}\\\" of @else statement\",\n  rejected: \"Unexpected newline after \\\"}\\\" of @else statement\"\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/at-if-closing-brace-newline-after/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (expectation) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\"always-last-in-chain\"]\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    sassConditionalBraceNLAfterChecker({ root: root, result: result, ruleName: ruleName, atRuleName: \"if\", expectation: expectation, messages: messages });\n  };\n};\n\nexports.sassConditionalBraceNLAfterChecker = sassConditionalBraceNLAfterChecker;\n\nvar _utils = require(\"../../utils\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"at-if-closing-brace-newline-after\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expected: \"Expected newline after \\\"}\\\" of @if statement\",\n  rejected: \"Unexpected newline after \\\"}\\\" of @if statement\"\n});\n\n/**\n * The core logic for this rule. Can be imported by other rules with similar\n * logic, namely at-else-closing-brace-newline-after\n *\n * @param {Object} args -- Named arguments object\n * @param {PostCSS root} args.root\n * @param {PostCSS result} args.result\n * @param {String ruleName} args.ruleName - needed for `report` function\n * @param {String} args.atRuleName - the name of the at-rule to be checked, e.g. \"if\", \"else\"\n * @param {Object} args.messages - returned by stylelint.utils.ruleMessages\n * @return {undefined}\n */\nfunction sassConditionalBraceNLAfterChecker(_ref) {\n  var root = _ref.root,\n      result = _ref.result,\n      ruleName = _ref.ruleName,\n      atRuleName = _ref.atRuleName,\n      expectation = _ref.expectation,\n      messages = _ref.messages;\n\n  function complain(node, message, index) {\n    _stylelint.utils.report({\n      result: result,\n      ruleName: ruleName,\n      node: node,\n      message: message,\n      index: index\n    });\n  }\n\n  root.walkAtRules(function (atrule) {\n    // Do nothing if it's not an @if\n    if (atrule.name !== atRuleName) {\n      return;\n    }\n\n    var nextNode = atrule.next();\n    if (!nextNode) {\n      return;\n    }\n\n    var nextBefore = nextNode.raws.before;\n    var hasNewLinesBeforeNext = nextBefore && !(0, _utils.isSingleLineString)(nextBefore);\n    var reportIndex = atrule.toString().length;\n\n    if (expectation === \"always-last-in-chain\") {\n      // If followed by @else, no newline is needed\n      if (nextNode.type === \"atrule\" && (nextNode.name === \"else\" || nextNode.name === \"elseif\")) {\n        if (hasNewLinesBeforeNext) {\n          complain(atrule, messages.rejected, reportIndex);\n        }\n      } else {\n        if (!hasNewLinesBeforeNext) {\n          complain(atrule, messages.expected, reportIndex);\n        }\n      }\n    }\n  });\n}","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/at-else-closing-brace-space-after/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (expectation) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\"always-intermediate\", \"never-intermediate\"]\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    (0, _atIfClosingBraceSpaceAfter.sassConditionalBraceSpaceAfterChecker)({ root: root, result: result, ruleName: ruleName, atRuleName: \"else\", expectation: expectation, messages: messages });\n  };\n};\n\nvar _utils = require(\"../../utils\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar _atIfClosingBraceSpaceAfter = require(\"../at-if-closing-brace-space-after\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"at-else-closing-brace-space-after\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expected: \"Expected single space after \\\"}\\\" of @else statement\",\n  rejected: \"Unexpected space after \\\"}\\\" of @else statement\"\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/at-if-closing-brace-space-after/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (expectation) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\"always-intermediate\", \"never-intermediate\"]\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    sassConditionalBraceSpaceAfterChecker({ root: root, result: result, ruleName: ruleName, atRuleName: \"if\", expectation: expectation, messages: messages });\n  };\n};\n\nexports.sassConditionalBraceSpaceAfterChecker = sassConditionalBraceSpaceAfterChecker;\n\nvar _utils = require(\"../../utils\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"at-if-closing-brace-space-after\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expected: \"Expected single space after \\\"}\\\" of @if statement\",\n  rejected: \"Unexpected space after \\\"}\\\" of @if statement\"\n});\n\n/**\n * The core logic for this rule. Can be imported by other rules with similar\n * logic, namely at-else-closing-brace-space-after\n *\n * @param {Object} args -- Named arguments object\n * @param {PostCSS root} args.root\n * @param {PostCSS result} args.result\n * @param {String ruleName} args.ruleName - needed for `report` function\n * @param {String} args.atRuleName - the name of the at-rule to be checked, e.g. \"if\", \"else\"\n * @param {Object} args.messages - returned by stylelint.utils.ruleMessages\n * @return {undefined} \n */\nfunction sassConditionalBraceSpaceAfterChecker(_ref) {\n  var root = _ref.root,\n      result = _ref.result,\n      ruleName = _ref.ruleName,\n      atRuleName = _ref.atRuleName,\n      expectation = _ref.expectation,\n      messages = _ref.messages;\n\n  function complain(node, message, index) {\n    _stylelint.utils.report({\n      result: result,\n      ruleName: ruleName,\n      node: node,\n      message: message,\n      index: index\n    });\n  }\n\n  root.walkAtRules(function (atrule) {\n    // Do nothing if it's not an @if\n    if (atrule.name !== atRuleName) {\n      return;\n    }\n\n    var nextNode = atrule.next();\n    var hasSpaceAfter = nextNode && nextNode.raws.before === \" \";\n    var hasWhiteSpaceAfter = nextNode && nextNode.raws.before !== \"\";\n    var reportIndex = atrule.toString().length;\n\n    // When followed by an @else\n    if (nextNode && nextNode.type === \"atrule\" && nextNode.name === \"else\") {\n      // A single space is needed\n      if (expectation === \"always-intermediate\" && !hasSpaceAfter) {\n        complain(atrule, messages.expected, reportIndex);\n      } else if (expectation === \"never-intermediate\" && hasWhiteSpaceAfter) {\n        // No whitespace is needed\n        complain(atrule, messages.rejected, reportIndex);\n      }\n    }\n  });\n}","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/at-else-empty-line-before/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (expectation) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\"never\"]\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkAtRules(function (atrule) {\n\n      if (atrule.name !== \"else\") {\n        return;\n      }\n\n      // Don't need to ignore \"the first rule in a stylesheet\", etc, cases\n      // because @else should always go after @if\n\n      if (!(0, _utils.hasEmptyLine)(atrule.raws.before)) {\n        return;\n      }\n\n      _stylelint.utils.report({\n        message: messages.rejected,\n        node: atrule,\n        result: result,\n        ruleName: ruleName\n      });\n    });\n  };\n};\n\nvar _utils = require(\"../../utils\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"at-else-empty-line-before\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  rejected: \"Unxpected empty line before @else\"\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/at-function-pattern/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (pattern) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: pattern,\n      possible: [_lodash.isRegExp, _lodash.isString]\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    var regexpPattern = (0, _lodash.isString)(pattern) ? new RegExp(pattern) : pattern;\n\n    root.walkAtRules(function (decl) {\n      if (decl.name !== \"function\") {\n        return;\n      }\n\n      // Stripping the function of its arguments\n      var funcName = decl.params.replace(/(\\s*?)\\((?:\\s|\\S)*\\)/g, \"\");\n      if (regexpPattern.test(funcName)) {\n        return;\n      }\n\n      _stylelint.utils.report({\n        message: messages.expected,\n        node: decl,\n        result: result,\n        ruleName: ruleName\n      });\n    });\n  };\n};\n\nvar _lodash = require(\"lodash\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar _utils = require(\"../../utils\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"at-function-pattern\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expected: \"Expected @function name to match specified pattern\"\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/at-import-no-partial-extension/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (on, options) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: on\n    }, {\n      actual: options,\n      possible: {\n        // Accepting array of either strings or regular expressions\n        ignoreExtensions: function ignoreExtensions(str) {\n          return (0, _lodash.isRegExp)(str) || (0, _lodash.isString)(str);\n        }\n      },\n      optional: true\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    result.warn(\"The 'at-import-no-partial-extension' rule has been deprecated, \" + \"and will be removed in '2.0'. Instead, use 'at-import-partial-extension-blacklist' or 'at-import-partial-extension-whitelist' rules.\", {\n      stylelintType: \"deprecation\"\n    });\n\n    function checkPathForUnderscore(path, decl) {\n      // Stripping trailing quotes and whitespaces, if any\n      var pathStripped = path.replace(/^\\s*?(\"|')\\s*/, \"\").replace(/\\s*(\"|')\\s*?$/, \"\");\n      var extension = _path2.default.extname(pathStripped).slice(1);\n\n      // If the extension is not empty\n      if (!extension) {\n        return;\n      }\n\n      // Skipping importing CSS: url(), \".css\", URI with a protocol, media\n      if (pathStripped.slice(0, 4) === \"url(\" || pathStripped.slice(-4) === \".css\" || pathStripped.search(\"//\") !== -1 || pathStripped.search(/(?:\\s|[,)\"'])\\w+$/) !== -1) {\n        return;\n      }\n\n      if (options && options.ignoreExtensions) {\n        // Return if...\n        if (options.ignoreExtensions.some(function (ignoredExt) {\n          // the extension matches one of the ignored strings or Regexps\n          return (0, _lodash.isString)(ignoredExt) && ignoredExt === extension || (0, _lodash.isRegExp)(ignoredExt) && extension.search(ignoredExt) !== -1;\n        })) {\n          return;\n        }\n      }\n\n      _stylelint.utils.report({\n        message: messages.expected,\n        node: decl,\n        result: result,\n        ruleName: ruleName\n      });\n    }\n\n    root.walkAtRules(\"import\", function (atRule) {\n      // Processing comma-separated lists of import paths\n      atRule.params.split(\",\").forEach(function (path) {\n        checkPathForUnderscore(path, atRule);\n      });\n    });\n  };\n};\n\nvar _lodash = require(\"lodash\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar _utils = require(\"../../utils\");\n\nvar _path = require(\"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"at-import-no-partial-extension\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expected: \"Unexpected file extension in imported partial name\"\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/at-import-no-partial-leading-underscore/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (actual) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, { actual: actual });\n    if (!validOptions) {\n      return;\n    }\n\n    function checkPathForUnderscore(path, decl) {\n      // Stripping trailing quotes and whitespaces, if any\n      var pathStripped = path.replace(/^\\s*?(\"|')\\s*/, \"\").replace(/\\s*(\"|')\\s*?$/, \"\");\n\n      // Searching a _ at the start of filename\n      if (pathStripped.search(/(?:^|\\/|\\\\)_[^/]+$/) === -1) {\n        return;\n      }\n\n      // Skipping importing CSS: url(), \".css\", URI with a protocol, media\n      if (pathStripped.slice(0, 4) === \"url(\" || pathStripped.slice(-4) === \".css\" || pathStripped.search(\"//\") !== -1 || pathStripped.search(/(?:\\s|[,)\"'])\\w+$/) !== -1) {\n        return;\n      }\n\n      _stylelint.utils.report({\n        message: messages.expected,\n        node: decl,\n        result: result,\n        ruleName: ruleName\n      });\n    }\n\n    root.walkAtRules(\"import\", function (decl) {\n      // Processing comma-separated lists of import paths\n      decl.params.split(\",\").forEach(function (path) {\n        checkPathForUnderscore(path, decl);\n      });\n    });\n  };\n};\n\nvar _stylelint = require(\"stylelint\");\n\nvar _utils = require(\"../../utils\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"at-import-no-partial-leading-underscore\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expected: \"Unexpected leading underscore in imported partial name\"\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/at-import-partial-extension-blacklist/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (blacklistOption) {\n  var blacklist = [].concat(blacklistOption);\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: blacklistOption,\n      possible: [_lodash.isString, _lodash.isRegExp]\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    function checkPathForUnderscore(path, decl) {\n      // Stripping trailing quotes and whitespaces, if any\n      var pathStripped = path.replace(/^\\s*?(\"|')\\s*/, \"\").replace(/\\s*(\"|')\\s*?$/, \"\");\n      var extension = _path2.default.extname(pathStripped).slice(1);\n      // Save this separately to be able to pass the original string to report()\n      var extensionNormalized = extension.toLowerCase();\n\n      // If the extension is empty\n      if (!extension) {\n        return;\n      }\n\n      // Skipping importing CSS: url(), \".css\", URI with a protocol, media\n      if (pathStripped.slice(0, 4) === \"url(\" || pathStripped.slice(-4) === \".css\" || pathStripped.search(\"//\") !== -1 || pathStripped.search(/(?:\\s|[,)\"'])\\w+$/) !== -1) {\n        return;\n      }\n\n      blacklist.forEach(function (ext) {\n        if ((0, _lodash.isString)(ext) && extensionNormalized === ext || (0, _lodash.isRegExp)(ext) && extensionNormalized.search(ext) !== -1) {\n          _stylelint.utils.report({\n            message: messages.rejected(extension),\n            node: decl,\n            word: extension,\n            result: result,\n            ruleName: ruleName\n          });\n        }\n      });\n    }\n\n    root.walkAtRules(\"import\", function (atRule) {\n      // Processing comma-separated lists of import paths\n      atRule.params.split(\",\").forEach(function (path) {\n        checkPathForUnderscore(path, atRule);\n      });\n    });\n  };\n};\n\nvar _lodash = require(\"lodash\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar _utils = require(\"../../utils\");\n\nvar _path = require(\"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"at-import-partial-extension-blacklist\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  rejected: function rejected(ext) {\n    return \"Unexpected extension \\\".\" + ext + \"\\\" in imported partial name\";\n  }\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/at-import-partial-extension-whitelist/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (whitelistOption) {\n  var whitelist = [].concat(whitelistOption);\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: whitelistOption,\n      possible: [_lodash.isString, _lodash.isRegExp]\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    function checkPathForUnderscore(path, decl) {\n      // Stripping trailing quotes and whitespaces, if any\n      var pathStripped = path.replace(/^\\s*?(\"|')\\s*/, \"\").replace(/\\s*(\"|')\\s*?$/, \"\");\n      var extension = _path2.default.extname(pathStripped).slice(1);\n      // Save this separately to be able to pass the original string to report()\n      var extensionNormalized = extension.toLowerCase();\n\n      // If the extension is empty\n      if (!extension) {\n        return;\n      }\n\n      // Skipping importing CSS: url(), \".css\", URI with a protocol, media\n      if (pathStripped.slice(0, 4) === \"url(\" || pathStripped.slice(-4) === \".css\" || pathStripped.search(\"//\") !== -1 || pathStripped.search(/(?:\\s|[,)\"'])\\w+$/) !== -1) {\n        return;\n      }\n\n      if (whitelist.some(function (ext) {\n        return (0, _lodash.isString)(ext) && extensionNormalized === ext || (0, _lodash.isRegExp)(ext) && extensionNormalized.search(ext) !== -1;\n      })) {\n        return;\n      }\n\n      _stylelint.utils.report({\n        message: messages.rejected(extension),\n        node: decl,\n        word: extension,\n        result: result,\n        ruleName: ruleName\n      });\n    }\n\n    root.walkAtRules(\"import\", function (atRule) {\n      // Processing comma-separated lists of import paths\n      atRule.params.split(\",\").forEach(function (path) {\n        checkPathForUnderscore(path, atRule);\n      });\n    });\n  };\n};\n\nvar _lodash = require(\"lodash\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar _utils = require(\"../../utils\");\n\nvar _path = require(\"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"at-import-partial-extension-whitelist\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  rejected: function rejected(ext) {\n    return \"Unexpected extension \\\".\" + ext + \"\\\" in imported partial name\";\n  }\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/at-mixin-argumentless-call-parentheses/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (value) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: value,\n      possible: [\"always\", \"never\"]\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkAtRules(\"include\", function (mixinCall) {\n      // If it is \"No parens in argumentless calls\"\n      if (value === \"never\" && mixinCall.params.search(/\\(\\s*?\\)\\s*?$/) === -1) {\n        return;\n      }\n      // If it is \"Always use parens\"\n      if (value === \"always\" && mixinCall.params.search(/\\(/) !== -1) {\n        return;\n      }\n\n      var mixinName = /\\s*(\\S*?)\\s*(?:\\(|$)/.exec(mixinCall.params)[1];\n\n      _stylelint.utils.report({\n        message: messages[value === \"never\" ? \"rejected\" : \"expected\"](mixinName),\n        node: mixinCall,\n        result: result,\n        ruleName: ruleName\n      });\n    });\n  };\n};\n\nvar _stylelint = require(\"stylelint\");\n\nvar _utils = require(\"../../utils\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"at-mixin-argumentless-call-parentheses\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expected: function expected(mixin) {\n    return \"Expected parentheses in mixin \\\"\" + mixin + \"\\\" call\";\n  },\n  rejected: function rejected(mixin) {\n    return \"Unexpected parentheses in argumentless mixin \\\"\" + mixin + \"\\\" call\";\n  }\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/at-mixin-no-argumentless-call-parentheses/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (actual) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, { actual: actual });\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkAtRules(\"include\", function (decl) {\n      if (decl.params.search(/\\(\\s*?\\)\\s*?$/) === -1) {\n        return;\n      }\n\n      _stylelint.utils.report({\n        message: messages.expected,\n        node: decl,\n        result: result,\n        ruleName: ruleName\n      });\n    });\n  };\n};\n\nvar _stylelint = require(\"stylelint\");\n\nvar _utils = require(\"../../utils\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"at-mixin-no-argumentless-call-parentheses\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expected: \"Unexpected parentheses in argumentless @mixin call\"\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/at-mixin-pattern/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (pattern) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: pattern,\n      possible: [_lodash.isRegExp, _lodash.isString]\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    var regexpPattern = (0, _lodash.isString)(pattern) ? new RegExp(pattern) : pattern;\n\n    root.walkAtRules(function (decl) {\n      if (decl.name !== \"mixin\") {\n        return;\n      }\n\n      // Stripping the mixin of its arguments\n      var mixinName = decl.params.replace(/(\\s*?)\\((?:\\s|\\S)*\\)/g, \"\");\n      if (regexpPattern.test(mixinName)) {\n        return;\n      }\n\n      _stylelint.utils.report({\n        message: messages.expected,\n        node: decl,\n        result: result,\n        ruleName: ruleName\n      });\n    });\n  };\n};\n\nvar _lodash = require(\"lodash\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar _utils = require(\"../../utils\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"at-mixin-pattern\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expected: \"Expected @mixin name to match specified pattern\"\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/declaration-nested-properties/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (expectation, options) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\"always\", \"never\"]\n    }, {\n      actual: options,\n      possible: {\n        except: [\"only-of-namespace\"]\n      },\n      optional: true\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    if (expectation === \"always\") {\n      root.walk(function (item) {\n        if (item.type !== \"rule\" && item.type !== \"atrule\") {\n          return;\n        }\n\n        var warningCandidates = {};\n\n        item.each(function (decl) {\n          var prop = decl.prop,\n              type = decl.type,\n              selector = decl.selector;\n\n          // Looking for namespaced non-nested properties\n          // Namespaced prop is basically a prop with a `-` in a name, e.g. `margin-top`\n\n          if (type === \"decl\") {\n            if (!(0, _utils.isStandardSyntaxProperty)(prop)) {\n              return;\n            }\n\n            // Add simple namespaced prop decls to warningCandidates.ns\n            // (prop names with browser prefixes are ignored)\n            var seekNamespace = /^([a-zA-Z0-9]+)-/.exec(prop);\n            if (seekNamespace && seekNamespace[1]) {\n              var ns = seekNamespace[1];\n              if (!warningCandidates.hasOwnProperty(ns)) {\n                warningCandidates[ns] = [];\n              }\n              warningCandidates[ns].push({ node: decl });\n            }\n          }\n\n          // Nested props, `prop: [value] { <nested decls> }`\n          if (type === \"rule\") {\n            // `background:red {` - selector;\n            // `background: red {` - nested prop; space is decisive here\n            var testForProp = (0, _utils.parseNestedPropRoot)(selector);\n\n            if (testForProp && testForProp.propName !== undefined) {\n              var _ns = testForProp.propName.value;\n              if (!warningCandidates.hasOwnProperty(_ns)) {\n                warningCandidates[_ns] = [];\n              }\n              warningCandidates[_ns].push({\n                node: decl,\n                nested: true\n              });\n            }\n          }\n        });\n\n        // Now check if the found properties deserve warnings\n        Object.keys(warningCandidates).forEach(function (namespace) {\n          var exceptIfOnlyOfNs = (0, _utils.optionsHaveException)(options, \"only-of-namespace\");\n          var moreThanOneProp = warningCandidates[namespace].length > 1;\n\n          warningCandidates[namespace].forEach(function (candidate) {\n            if (candidate.nested === true) {\n              if (exceptIfOnlyOfNs) {\n                // If there is only one prop inside a nested prop - warn (reverse \"always\")\n                if (candidate.nested === true && candidate.node.nodes.length === 1) {\n                  _stylelint.utils.report({\n                    message: messages.rejected(namespace),\n                    node: candidate.node,\n                    result: result,\n                    ruleName: ruleName\n                  });\n                }\n              }\n            } else {\n              // Don't warn on non-nested namespaced props if there are\n              // less than 2 of them, and except: \"only-of-namespace\" is set\n              if (exceptIfOnlyOfNs && !moreThanOneProp) {\n                return;\n              }\n\n              _stylelint.utils.report({\n                message: messages.expected(candidate.node.prop),\n                node: candidate.node,\n                result: result,\n                ruleName: ruleName\n              });\n            }\n          });\n        });\n      });\n    } else if (expectation === \"never\") {\n      root.walk(function (item) {\n        // Just check if there are ANY nested props\n        if (item.type === \"rule\") {\n          // `background:red {` - selector;\n          // `background: red {` - nested prop; space is decisive here\n          var testForProp = (0, _utils.parseNestedPropRoot)(item.selector);\n\n          if (testForProp && testForProp.propName !== undefined) {\n            _stylelint.utils.report({\n              message: messages.rejected(testForProp.propName.value),\n              result: result,\n              ruleName: ruleName,\n              node: item\n            });\n          }\n        }\n      });\n    }\n  };\n};\n\nvar _utils = require(\"../../utils\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"declaration-nested-properties\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expected: function expected(prop) {\n    return \"Expected property \\\"\" + prop + \"\\\" to be in a nested form\";\n  },\n  rejected: function rejected(prop) {\n    return \"Unexpected nested property \\\"\" + prop + \"\\\"\";\n  }\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/declaration-nested-properties-no-divided-groups/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (expectation) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: expectation\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    root.walk(function (item) {\n      if (item.type !== \"rule\" && item.type !== \"atrule\") {\n        return;\n      }\n\n      var nestedGroups = {};\n\n      // Find all nested property groups\n      item.each(function (decl) {\n        if (decl.type !== \"rule\") {\n          return;\n        }\n        var testForProp = (0, _utils.parseNestedPropRoot)(decl.selector);\n\n        if (testForProp && testForProp.propName !== undefined) {\n          var ns = testForProp.propName.value;\n          if (!nestedGroups.hasOwnProperty(ns)) {\n            nestedGroups[ns] = [];\n          }\n          nestedGroups[ns].push(decl);\n        }\n      });\n\n      Object.keys(nestedGroups).forEach(function (namespace) {\n        // Only warn if there are more than one nested groups with equal namespaces\n        if (nestedGroups[namespace].length === 1) {\n          return;\n        }\n        nestedGroups[namespace].forEach(function (group) {\n          _stylelint.utils.report({\n            message: messages.expected(namespace),\n            node: group,\n            result: result,\n            ruleName: ruleName\n          });\n        });\n      });\n    });\n  };\n};\n\nvar _utils = require(\"../../utils\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"declaration-nested-properties-no-divided-groups\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expected: function expected(prop) {\n    return \"Expected all nested properties of \\\"\" + prop + \"\\\" namespace to be in one nested group\";\n  }\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/dollar-variable-colon-newline-after/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (expectation) {\n  var checker = (0, _utils.whitespaceChecker)(\"newline\", expectation, messages);\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\"always\", \"always-multi-line\"]\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkDecls(function (decl) {\n      if (!decl.prop || decl.prop[0] !== \"$\") {\n        return;\n      }\n\n      // Get the raw $var, and only that\n      var endOfPropIndex = (0, _utils.declarationValueIndex)(decl) + decl.raw(\"between\").length - 1;\n      // `$var:`, `$var :`\n      var propPlusColon = decl.toString().slice(0, endOfPropIndex);\n\n      var _loop = function _loop(i, l) {\n        if (propPlusColon[i] !== \":\") {\n          return \"continue\";\n        }\n        var indexToCheck = propPlusColon.substr(propPlusColon[i], 3) === \"/*\" ? propPlusColon.indexOf(\"*/\", i) + 1 : i;\n\n        checker.afterOneOnly({\n          source: propPlusColon,\n          index: indexToCheck,\n          lineCheckStr: decl.value,\n          err: function err(m) {\n            _stylelint.utils.report({\n              message: m,\n              node: decl,\n              index: indexToCheck,\n              result: result,\n              ruleName: ruleName\n            });\n          }\n        });\n        return \"break\";\n      };\n\n      _loop2: for (var i = 0, l = propPlusColon.length; i < l; i++) {\n        var _ret = _loop(i, l);\n\n        switch (_ret) {\n          case \"continue\":\n            continue;\n\n          case \"break\":\n            break _loop2;}\n      }\n    });\n  };\n};\n\nvar _utils = require(\"../../utils\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"dollar-variable-colon-newline-after\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expectedAfter: function expectedAfter() {\n    return \"Expected newline after \\\":\\\"\";\n  },\n  expectedAfterMultiLine: function expectedAfterMultiLine() {\n    return \"Expected newline after \\\":\\\" with a multi-line value\";\n  }\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/dollar-variable-colon-space-after/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (expectation) {\n  var checker = (0, _utils.whitespaceChecker)(\"space\", expectation, messages);\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\"always\", \"never\", \"always-single-line\"]\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    variableColonSpaceChecker({\n      root: root,\n      result: result,\n      locationChecker: checker.after,\n      checkedRuleName: ruleName\n    });\n  };\n};\n\nexports.variableColonSpaceChecker = variableColonSpaceChecker;\n\nvar _utils = require(\"../../utils\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"dollar-variable-colon-space-after\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expectedAfter: function expectedAfter() {\n    return \"Expected single space after \\\":\\\"\";\n  },\n  rejectedAfter: function rejectedAfter() {\n    return \"Unexpected whitespace after \\\":\\\"\";\n  },\n  expectedAfterSingleLine: function expectedAfterSingleLine() {\n    return \"Expected single space after \\\":\\\" with a single-line value\";\n  }\n});\n\nfunction variableColonSpaceChecker(_ref) {\n  var locationChecker = _ref.locationChecker,\n      root = _ref.root,\n      result = _ref.result,\n      checkedRuleName = _ref.checkedRuleName;\n\n  root.walkDecls(function (decl) {\n\n    if (decl.prop === undefined || decl.prop[0] !== \"$\") {\n      return;\n    }\n\n    // Get the raw $var, and only that\n    var endOfPropIndex = (0, _utils.declarationValueIndex)(decl) + decl.raw(\"between\").length - 1;\n    // `$var:`, `$var :`\n    var propPlusColon = decl.toString().slice(0, endOfPropIndex);\n\n    var _loop = function _loop(i) {\n      if (propPlusColon[i] !== \":\") {\n        return \"continue\";\n      }\n      locationChecker({\n        source: propPlusColon,\n        index: i,\n        lineCheckStr: decl.value,\n        err: function err(m) {\n          _stylelint.utils.report({\n            message: m,\n            node: decl,\n            index: i,\n            result: result,\n            ruleName: checkedRuleName\n          });\n        }\n      });\n      return \"break\";\n    };\n\n    _loop2: for (var i = 0; i < propPlusColon.length; i++) {\n      var _ret = _loop(i);\n\n      switch (_ret) {\n        case \"continue\":\n          continue;\n\n        case \"break\":\n          break _loop2;}\n    }\n  });\n}","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/dollar-variable-colon-space-before/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (expectation) {\n  var checker = (0, _utils.whitespaceChecker)(\"space\", expectation, messages);\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\"always\", \"never\"]\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    (0, _dollarVariableColonSpaceAfter.variableColonSpaceChecker)({\n      root: root,\n      result: result,\n      locationChecker: checker.before,\n      checkedRuleName: ruleName\n    });\n  };\n};\n\nvar _utils = require(\"../../utils\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar _dollarVariableColonSpaceAfter = require(\"../dollar-variable-colon-space-after\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"dollar-variable-colon-space-before\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expectedBefore: function expectedBefore() {\n    return \"Expected single space before \\\":\\\"\";\n  },\n  rejectedBefore: function rejectedBefore() {\n    return \"Unexpected whitespace before \\\":\\\"\";\n  }\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/dollar-variable-empty-line-before/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (expectation, options) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\"always\", \"never\"]\n    }, {\n      actual: options,\n      possible: {\n        except: [\"first-nested\", \"after-comment\", \"after-dollar-variable\"],\n        ignore: [\"after-comment\", \"inside-single-line-block\"]\n      },\n      optional: true\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkDecls(function (decl) {\n\n      if (!isDollarVar(decl)) {\n        return;\n      }\n\n      // Always ignore the first $var in a stylesheet\n      if (decl === root.first) {\n        return;\n      }\n\n      // If ignoring vars after comments is set\n      if ((0, _utils.optionsHaveIgnored)(options, \"after-comment\") && decl.prev() && decl.prev().type === \"comment\") {\n        return;\n      }\n\n      // If ignoring single-line blocks\n      if ((0, _utils.optionsHaveIgnored)(options, \"inside-single-line-block\") && decl.parent.type !== \"root\" && (0, _utils.isSingleLineString)((0, _utils.blockString)(decl.parent))) {\n        return;\n      }\n\n      var expectHasEmptyLineBefore = expectation === \"always\";\n\n      // Reverse for a variable that is a first child of its parent\n      if ((0, _utils.optionsHaveException)(options, \"first-nested\") && decl === decl.parent.first) {\n        expectHasEmptyLineBefore = !expectHasEmptyLineBefore;\n      }\n\n      // Reverse if after a comment\n      if ((0, _utils.optionsHaveException)(options, \"after-comment\") && decl.prev() && decl.prev().type === \"comment\") {\n        expectHasEmptyLineBefore = !expectHasEmptyLineBefore;\n      }\n\n      // Reverse if after another $-variable\n      if ((0, _utils.optionsHaveException)(options, \"after-dollar-variable\") && decl.prev() && isDollarVar(decl.prev())) {\n        expectHasEmptyLineBefore = !expectHasEmptyLineBefore;\n      }\n\n      if (expectHasEmptyLineBefore === (0, _utils.hasEmptyLine)(decl.raws.before)) {\n        return;\n      }\n\n      _stylelint.utils.report({\n        message: expectHasEmptyLineBefore ? messages.expected : messages.rejected,\n        node: decl,\n        result: result,\n        ruleName: ruleName\n      });\n    });\n  };\n};\n\nvar _utils = require(\"../../utils\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"dollar-variable-empty-line-before\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expected: \"Expected an empty line before $-variable\",\n  rejected: \"Unxpected empty line before $-variable\"\n});\n\nfunction isDollarVar(node) {\n  return node.prop && node.prop[0] === \"$\";\n}","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/dollar-variable-no-missing-interpolation/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (actual) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, { actual: actual });\n    if (!validOptions) {\n      return;\n    }\n\n    var stringVars = [];\n    var vars = [];\n\n    function findVars(node) {\n      node.walkDecls(function (decl) {\n        var prop = decl.prop,\n            value = decl.value;\n\n\n        if (!isSassVar(prop) || (0, _lodash.includes)(vars, prop)) {\n          return;\n        }\n\n        if (isStringVal(value)) {\n          stringVars.push(prop);\n        }\n\n        vars.push(prop);\n      });\n    }\n\n    findVars(root);\n    root.walkRules(findVars);\n\n    if (!vars.length) {\n      return;\n    }\n\n    function shouldReport(node, value) {\n      if (isAtSupports(node) || isCustomIdentProp(node)) {\n        return (0, _lodash.includes)(stringVars, value);\n      }\n      if (isCustomIdentAtRule(node)) {\n        return (0, _lodash.includes)(vars, value);\n      }\n      return false;\n    }\n\n    function report(node, value) {\n      var name = node.name,\n          prop = node.prop,\n          type = node.type;\n\n      var nodeName = isAtRule(type) ? \"@\" + name : prop;\n\n      _stylelint.utils.report({\n        ruleName: ruleName,\n        result: result,\n        node: node,\n        message: messages.rejected(nodeName, value)\n      });\n    }\n\n    function exitEarly(node) {\n      return node.type !== \"word\" || !node.value;\n    }\n\n    function walkValues(node, value) {\n      (0, _postcssValueParser2.default)(value).walk(function (valNode) {\n        var value = valNode.value;\n\n        if (exitEarly(valNode) || !shouldReport(node, value)) {\n          return;\n        }\n        report(node, value);\n      });\n    }\n\n    root.walkDecls(toRegex(customIdentProps), function (decl) {\n      walkValues(decl, decl.value);\n    });\n\n    root.walkAtRules(toRegex(customIdentAtRules), function (atRule) {\n      walkValues(atRule, atRule.params);\n    });\n  };\n};\n\nvar _lodash = require(\"lodash\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar _utils = require(\"../../utils\");\n\nvar _postcssValueParser = require(\"postcss-value-parser\");\n\nvar _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"dollar-variable-no-missing-interpolation\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  rejected: function rejected(n, v) {\n    return \"Expected variable \" + v + \" to be interpolated when using it with \" + n;\n  }\n});\n\n// https://developer.mozilla.org/en/docs/Web/CSS/custom-ident#Lists_of_excluded_values\nvar customIdentProps = [\"animation\", \"animation-name\", \"counter-reset\", \"counter-increment\", \"list-style-type\", \"will-change\"];\n\n// https://developer.mozilla.org/en/docs/Web/CSS/At-rule\nvar customIdentAtRules = [\"counter-style\", \"keyframes\", \"supports\"];\n\nfunction isAtRule(type) {\n  return type === \"atrule\";\n}\n\nfunction isCustomIdentAtRule(node) {\n  return isAtRule(node.type) && (0, _lodash.includes)(customIdentAtRules, node.name);\n}\n\nfunction isCustomIdentProp(node) {\n  return (0, _lodash.includes)(customIdentProps, node.prop);\n}\n\nfunction isAtSupports(node) {\n  return isAtRule(node.type) && node.name === \"supports\";\n}\n\nfunction isSassVar(value) {\n  return value[0] === \"$\";\n}\n\nfunction isStringVal(value) {\n  return (/^(\"|').*(\"|')$/.test(value)\n  );\n}\n\nfunction toRegex(arr) {\n  return new RegExp(\"(\" + arr.join(\"|\") + \")\");\n}","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/dollar-variable-pattern/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (pattern, options) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: pattern,\n      possible: [_lodash.isRegExp, _lodash.isString]\n    }, {\n      actual: options,\n      possible: {\n        ignore: [\"local\", \"global\"]\n      },\n      optional: true\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    var regexpPattern = (0, _lodash.isString)(pattern) ? new RegExp(pattern) : pattern;\n\n    root.walkDecls(function (decl) {\n      var prop = decl.prop;\n\n\n      if (prop[0] !== \"$\") {\n        return;\n      }\n      // If local or global variables need to be ignored\n      if ((0, _utils.optionsHaveIgnored)(options, \"global\") && decl.parent.type === \"root\" || (0, _utils.optionsHaveIgnored)(options, \"local\") && decl.parent.type !== \"root\") {\n        return;\n      }\n      if (regexpPattern.test(prop.slice(1))) {\n        return;\n      }\n\n      _stylelint.utils.report({\n        message: messages.expected,\n        node: decl,\n        result: result,\n        ruleName: ruleName\n      });\n    });\n  };\n};\n\nvar _lodash = require(\"lodash\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar _utils = require(\"../../utils\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"dollar-variable-pattern\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expected: \"Expected $ variable name to match specified pattern\"\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/double-slash-comment-empty-line-before/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (expectation, options) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\"always\", \"never\"]\n    }, {\n      actual: options,\n      possible: {\n        except: [\"first-nested\"],\n        ignore: [\"stylelint-commands\", \"between-comments\"]\n      },\n      optional: true\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkComments(function (comment) {\n\n      // Only process // comments\n      if (!comment.raws.inline && !comment.inline) {\n        return;\n      }\n\n      if ((0, _utils.isInlineComment)(comment)) {\n        return;\n      }\n\n      // Ignore the first node\n      if (comment === root.first) {\n        return;\n      }\n\n      // Optionally ignore stylelint commands\n      if (comment.text.indexOf(stylelintCommandPrefix) === 0 && (0, _utils.optionsHaveIgnored)(options, \"stylelint-commands\")) {\n        return;\n      }\n\n      // Optionally ignore newlines between comments\n      var prev = comment.prev();\n      if (prev && prev.type === \"comment\" && (0, _utils.optionsHaveIgnored)(options, \"between-comments\")) {\n        return;\n      }\n\n      var before = comment.raw(\"before\");\n\n      var expectEmptyLineBefore = function () {\n        if ((0, _utils.optionsHaveException)(options, \"first-nested\") && comment.parent !== root && comment === comment.parent.first) {\n          return false;\n        }\n        return expectation === \"always\";\n      }();\n\n      var hasEmptyLineBefore = before.search(/\\n\\s*?\\n/) !== -1;\n\n      // Return if the expectation is met\n      if (expectEmptyLineBefore === hasEmptyLineBefore) {\n        return;\n      }\n\n      var message = expectEmptyLineBefore ? messages.expected : messages.rejected;\n\n      _stylelint.utils.report({\n        message: message,\n        node: comment,\n        result: result,\n        ruleName: ruleName\n      });\n    });\n  };\n};\n\nvar _utils = require(\"../../utils\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"double-slash-comment-empty-line-before\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expected: \"Expected empty line before comment\",\n  rejected: \"Unexpected empty line before comment\"\n});\n\nvar stylelintCommandPrefix = \"stylelint-\";","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/double-slash-comment-inline/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (expectation, options) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\"always\", \"never\"]\n    }, {\n      actual: options,\n      possible: {\n        ignore: [\"stylelint-commands\"]\n      },\n      optional: true\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    var comments = (0, _utils.findCommentsInRaws)(root.source.input.css);\n    comments.forEach(function (comment) {\n      // Only process // comments\n      if (comment.type !== \"double-slash\") {\n        return;\n      }\n\n      // Optionally ignore stylelint commands\n      if (comment.text.indexOf(stylelintCommandPrefix) === 0 && (0, _utils.optionsHaveIgnored)(options, \"stylelint-commands\")) {\n        return;\n      }\n\n      var isInline = comment.inlineAfter || comment.inlineBefore;\n      var message = void 0;\n\n      if (isInline && expectation === \"never\") {\n        message = messages.rejected;\n      } else if (!isInline && expectation === \"always\") {\n        message = messages.expected;\n      } else {\n        return;\n      }\n\n      _stylelint.utils.report({\n        message: message,\n        node: root,\n        index: comment.source.start,\n        result: result,\n        ruleName: ruleName\n      });\n    });\n  };\n};\n\nvar _utils = require(\"../../utils\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"double-slash-comment-inline\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expected: \"Expected //-comment to be inline comment\",\n  rejected: \"Unexpected inline //-comment\"\n});\n\nvar stylelintCommandPrefix = \"stylelint-\";","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/double-slash-comment-whitespace-inside/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (expectation) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\"always\", \"never\"]\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    var comments = (0, _utils.findCommentsInRaws)(root.source.input.css);\n    comments.forEach(function (comment) {\n      // Only process // comments\n      if (comment.type !== \"double-slash\") {\n        return;\n      }\n      // if it's `//` - no warning whatsoever; if `// ` - then trailing\n      // whitespace rule will govern this\n      if (comment.text === \"\") {\n        return;\n      }\n\n      var message = void 0;\n\n      if (expectation === \"never\" && comment.raws.left !== \"\") {\n        message = messages.rejected;\n      } else if (comment.raws.left === \"\" && expectation === \"always\") {\n        message = messages.expected;\n      } else {\n        return;\n      }\n\n      _stylelint.utils.report({\n        message: message,\n        node: root,\n        index: comment.source.start + comment.raws.startToken.length,\n        result: result,\n        ruleName: ruleName\n      });\n    });\n  };\n};\n\nvar _utils = require(\"../../utils\");\n\nvar _stylelint = require(\"stylelint\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"double-slash-comment-whitespace-inside\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expected: \"Expected a space after //\",\n  rejected: \"Unexpected space after //\"\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/media-feature-value-dollar-variable/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (expectation) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\"always\", \"never\"]\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    var valueRegex = /:(?:\\s*?)(\\S.+?)(:?\\s*?)\\)/;\n    // In `(max-width: 10px )` find `: 10px )`.\n    // Got to go with that (the global search doesn't remember parens' insides)\n    // and parse it again afterwards to remove trailing junk\n    var valueRegexGlobal = new RegExp(valueRegex.source, \"g\");\n    // `$var-name_sth`\n    var variableRegex = /^\\$[A-Za-z_0-9-]+$/;\n    // `#{$var-name_sth}`\n    var interpolationVarRegex = /^#\\{\\s*?\\$[A-Za-z_0-9]+\\s*?\\}$/;\n\n    root.walkAtRules(\"media\", function (atRule) {\n      var found = atRule.params.match(valueRegexGlobal);\n      // If there are no values\n      if (!found || !found.length) {\n        return;\n      }\n      found.forEach(function (found) {\n        // ... parse `: 10px )` to `10px`\n        var valueParsed = found.match(valueRegex)[1];\n\n        // Just a shorthand to stylelint.utils.report()\n        function complain(message) {\n          _stylelint.utils.report({\n            ruleName: ruleName,\n            result: result,\n            node: atRule,\n            word: valueParsed,\n            message: message\n          });\n        }\n\n        // A value should be a single variable\n        // or it should be a single variable inside Sass interpolation\n        if (expectation === \"always\" && !(valueParsed.search(variableRegex) !== -1 || valueParsed.search(interpolationVarRegex) !== -1)) {\n          complain(messages.expected);\n        } else if (expectation === \"never\" && valueParsed.indexOf(\"$\") !== -1) {\n          // \"Never\" means no variables at all (functions allowed)\n          complain(messages.rejected);\n        }\n      });\n    });\n  };\n};\n\nvar _stylelint = require(\"stylelint\");\n\nvar _utils = require(\"../../utils\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"media-feature-value-dollar-variable\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  rejected: \"Unexpected dollar-variable as a media feature value\",\n  expected: \"Expected a dollar-variable (e.g. $var) to be used as a media feature value\"\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/operator-no-newline-after/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (expectation) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: expectation\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    (0, _operatorNoUnspaced.calculationOperatorSpaceChecker)({\n      root: root,\n      result: result,\n      checker: checkNewlineBefore\n    });\n  };\n};\n\nvar _stylelint = require(\"stylelint\");\n\nvar _utils = require(\"../../utils\");\n\nvar _operatorNoUnspaced = require(\"../operator-no-unspaced\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"operator-no-newline-after\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  rejected: function rejected(operator) {\n    return \"Unexpected newline after \\\"\" + operator + \"\\\"\";\n  }\n});\n\n/**\n * The checker function: whether there is a newline before THAT operator.\n */\nfunction checkNewlineBefore(_ref) {\n  var string = _ref.string,\n      globalIndex = _ref.globalIndex,\n      startIndex = _ref.startIndex,\n      endIndex = _ref.endIndex,\n      node = _ref.node,\n      result = _ref.result;\n\n  var symbol = string.substring(startIndex, endIndex + 1);\n  var newLineBefore = false;\n\n  var index = endIndex + 1;\n  while (index && (0, _utils.isWhitespace)(string[index])) {\n    if (string[index] === \"\\n\") {\n      newLineBefore = true;\n      break;\n    }\n    index++;\n  }\n\n  if (newLineBefore) {\n    _stylelint.utils.report({\n      ruleName: ruleName,\n      result: result,\n      node: node,\n      message: messages.rejected(symbol),\n      index: endIndex + globalIndex\n    });\n  }\n}","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/operator-no-unspaced/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (expectation) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: expectation\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    calculationOperatorSpaceChecker({\n      root: root,\n      result: result,\n      checker: checkSpaces\n    });\n  };\n};\n\nexports.calculationOperatorSpaceChecker = calculationOperatorSpaceChecker;\n\nvar _stylelint = require(\"stylelint\");\n\nvar _utils = require(\"../../utils\");\n\nvar _postcssMediaQueryParser = require(\"postcss-media-query-parser\");\n\nvar _postcssMediaQueryParser2 = _interopRequireDefault(_postcssMediaQueryParser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"operator-no-unspaced\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expectedAfter: function expectedAfter(operator) {\n    return \"Expected single space after \\\"\" + operator + \"\\\"\";\n  },\n  expectedBefore: function expectedBefore(operator) {\n    return \"Expected single space before \\\"\" + operator + \"\\\"\";\n  }\n});\n\n/**\n * The actual check for are there (un)necessary whitespaces\n */\nfunction checkSpaces(_ref) {\n  var string = _ref.string,\n      globalIndex = _ref.globalIndex,\n      startIndex = _ref.startIndex,\n      endIndex = _ref.endIndex,\n      node = _ref.node,\n      result = _ref.result;\n\n  var symbol = string.substring(startIndex, endIndex + 1);\n\n  var beforeOk = string[startIndex - 1] === \" \" && !(0, _utils.isWhitespace)(string[startIndex - 2]) || newlineBefore(string, startIndex - 1);\n  if (!beforeOk) {\n    _stylelint.utils.report({\n      ruleName: ruleName,\n      result: result,\n      node: node,\n      message: messages.expectedBefore(symbol),\n      index: startIndex + globalIndex\n    });\n  }\n\n  var afterOk = string[endIndex + 1] === \" \" && !(0, _utils.isWhitespace)(string[endIndex + 2]) || string[endIndex + 1] === \"\\n\" || string.substr(endIndex + 1, 2) === \"\\r\\n\";\n\n  if (!afterOk) {\n    _stylelint.utils.report({\n      ruleName: ruleName,\n      result: result,\n      node: node,\n      message: messages.expectedAfter(symbol),\n      index: endIndex + globalIndex\n    });\n  }\n}\n\nfunction newlineBefore(str, startIndex) {\n  var index = startIndex;\n  while (index && (0, _utils.isWhitespace)(str[index])) {\n    if (str[index] === \"\\n\") return true;\n    index--;\n  }\n  return false;\n}\n\n/**\n * The core rule logic function. This one can be imported by some other rules\n * that work with Sass operators\n *\n * @param {Object} args -- Named arguments object\n * @param {PostCSS Root} args.root\n * @param {PostCSS Result} args.result\n * @param {function} args.checker -- the function that is run against all the\n *    operators found in the input. Takes these arguments:\n *    {Object} cbArgs -- Named arguments object\n *    {string} cbArgs.string -- the input string (suspected operation)\n *    {number} cbArgs.globalIndex -- the string's index in a global input\n *    {number} cbArgs.startIndex -- the start index of a sybmol to inspect\n *    {number} cbArgs.endIndex -- the end index of a sybmol to inspect\n *      (two indexes needed to allow for `==`, `!=`, etc.)\n *    {PostCSS Node} cbArgs.node -- for stylelint.utils.report\n *    {PostCSS Result} cbArgs.result -- for stylelint.utils.report\n */\nfunction calculationOperatorSpaceChecker(_ref2) {\n  var root = _ref2.root,\n      result = _ref2.result,\n      checker = _ref2.checker;\n\n\n  /**\n   * Takes a string, finds all occurencies of Sass interpolaion in it, then\n   * finds all operators inside that interpolation\n   *\n   * @return {array} An array of ojbects { string, operators } - effectively,\n   *    a list of operators for each Sass interpolation occurence\n   */\n  function findInterpolation(string, startIndex) {\n    var interpolationRegex = /#{(.*?)}/g;\n    var results = [];\n    // Searching for interpolation\n    var match = interpolationRegex.exec(string);\n    startIndex = !isNaN(startIndex) ? Number(startIndex) : 0;\n    while (match !== null) {\n      results.push({\n        source: match[0],\n        operators: (0, _utils.findOperators)({\n          string: match[0],\n          globalIndex: match.index + startIndex\n        })\n      });\n      match = interpolationRegex.exec(string);\n    }\n    return results;\n  }\n\n  root.walk(function (item) {\n    var results = [];\n\n    // Check a value (`10px` in `width: 10px;`)\n    if (item.value !== undefined) {\n      results.push({\n        source: item.value,\n        operators: (0, _utils.findOperators)({\n          string: item.value,\n          globalIndex: (0, _utils.declarationValueIndex)(item),\n          // For Sass variable values some special rules apply\n          isAfterColon: item.prop[0] === \"$\"\n        })\n      });\n    }\n\n    // Property name\n    if (item.prop !== undefined) {\n      results = results.concat(findInterpolation(item.prop));\n    }\n    // Selector\n    if (item.selector !== undefined) {\n      results = results.concat(findInterpolation(item.selector));\n    }\n\n    if (item.type === \"atrule\") {\n\n      // Media queries\n      if (item.name === \"media\" || item.name === \"import\") {\n        (0, _postcssMediaQueryParser2.default)(item.params).walk(function (node) {\n          var type = node.type;\n          if ([\"keyword\", \"media-type\", \"media-feature\"].indexOf(type) !== -1) {\n            results = results.concat(findInterpolation(node.value, (0, _utils.atRuleParamIndex)(item) + node.sourceIndex));\n          } else if ([\"value\", \"url\"].indexOf(type) !== -1) {\n            results.push({\n              source: node.value,\n              operators: (0, _utils.findOperators)({\n                string: node.value,\n                globalIndex: (0, _utils.atRuleParamIndex)(item) + node.sourceIndex,\n                isAfterColon: true\n              })\n            });\n          }\n        });\n      } else {\n        // Function and mixin definitions and other rules\n        results.push({\n          source: item.params,\n          operators: (0, _utils.findOperators)({\n            string: item.params,\n            globalIndex: (0, _utils.atRuleParamIndex)(item),\n            isAfterColon: true\n          })\n        });\n      }\n    }\n\n    // All the strings have been parsed, now run whitespace checking\n    results.forEach(function (el) {\n      // Only if there are operators within a string\n      if (el.operators && el.operators.length > 0) {\n        el.operators.forEach(function (operator) {\n          checker({\n            string: el.source,\n            globalIndex: operator.globalIndex,\n            startIndex: operator.startIndex,\n            endIndex: operator.endIndex,\n            node: item,\n            result: result\n          });\n        });\n      }\n    });\n  });\n\n  // Checking interpolation inside comments\n  // We have to give up on PostCSS here because it skips some inline comments\n  (0, _utils.findCommentsInRaws)(root.source.input.css).forEach(function (comment) {\n    var startIndex = comment.source.start + comment.raws.startToken.length + comment.raws.left.length;\n    if (comment.type !== \"css\") {\n      return;\n    }\n\n    findInterpolation(comment.text).forEach(function (el) {\n      // Only if there are operators within a string\n      if (el.operators && el.operators.length > 0) {\n        el.operators.forEach(function (operator) {\n          checker({\n            string: el.source,\n            globalIndex: operator.globalIndex + startIndex,\n            startIndex: operator.startIndex,\n            endIndex: operator.endIndex,\n            node: root,\n            result: result\n          });\n        });\n      }\n    });\n  });\n}","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/operator-no-newline-before/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (expectation) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: expectation\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    (0, _operatorNoUnspaced.calculationOperatorSpaceChecker)({\n      root: root,\n      result: result,\n      checker: checkNewlineBefore\n    });\n  };\n};\n\nvar _stylelint = require(\"stylelint\");\n\nvar _utils = require(\"../../utils\");\n\nvar _operatorNoUnspaced = require(\"../operator-no-unspaced\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"operator-no-newline-before\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  rejected: function rejected(operator) {\n    return \"Unexpected newline before \\\"\" + operator + \"\\\"\";\n  }\n});\n\n/**\n * The checker function: whether there is a newline before THAT operator.\n */\nfunction checkNewlineBefore(_ref) {\n  var string = _ref.string,\n      globalIndex = _ref.globalIndex,\n      startIndex = _ref.startIndex,\n      endIndex = _ref.endIndex,\n      node = _ref.node,\n      result = _ref.result;\n\n  var symbol = string.substring(startIndex, endIndex + 1);\n  var newLineBefore = false;\n\n  var index = startIndex - 1;\n  while (index && (0, _utils.isWhitespace)(string[index])) {\n    if (string[index] === \"\\n\") {\n      newLineBefore = true;\n      break;\n    }\n    index--;\n  }\n\n  if (newLineBefore) {\n    _stylelint.utils.report({\n      ruleName: ruleName,\n      result: result,\n      node: node,\n      message: messages.rejected(symbol),\n      index: endIndex + globalIndex\n    });\n  }\n}","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/partial-no-import/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (on) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: on\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    if (root.source.input.file === undefined || !root.source.input.file) {\n      result.warn(\"The 'partial-no-import' rule won't work if linting in a code string without an actual file.\");\n      return;\n    }\n\n    var fileName = _path2.default.basename(root.source.input.file);\n    var extName = _path2.default.extname(root.source.input.file);\n\n    function checkImportForCSS(path, decl) {\n      // Stripping trailing quotes and whitespaces, if any\n      var pathStripped = path.replace(/^\\s*?(\"|')\\s*/, \"\").replace(/\\s*(\"|')\\s*?$/, \"\");\n\n      // Skipping importing CSS: url(), \".css\", URI with a protocol, media\n      if (pathStripped.slice(0, 4) === \"url(\" || pathStripped.slice(-4) === \".css\" || pathStripped.search(\"//\") !== -1 || pathStripped.search(/(?:\\s|[,)\"'])\\w+$/) !== -1) {\n        return;\n      }\n\n      _stylelint.utils.report({\n        message: messages.expected,\n        node: decl,\n        result: result,\n        ruleName: ruleName\n      });\n    }\n\n    // Usual CSS file\n    if (extName === \".css\") {\n      return;\n    }\n    // Not a partial\n    if (fileName[0] !== \"_\") {\n      return;\n    }\n\n    root.walkAtRules(\"import\", function (mixinCall) {\n      // Check if @import is treated as CSS import; report only if not\n      // Processing comma-separated lists of import paths\n      mixinCall.params.split(\",\").forEach(function (path) {\n        checkImportForCSS(path, mixinCall);\n      });\n    });\n  };\n};\n\nvar _stylelint = require(\"stylelint\");\n\nvar _utils = require(\"../../utils\");\n\nvar _path = require(\"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"partial-no-import\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expected: \"Unexpected @import in a partial\"\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/percent-placeholder-pattern/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (pattern) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {\n      actual: pattern,\n      possible: [_lodash.isRegExp, _lodash.isString]\n    });\n    if (!validOptions) {\n      return;\n    }\n\n    var placeholderPattern = (0, _lodash.isString)(pattern) ? new RegExp(pattern) : pattern;\n\n    // Checking placeholder definitions (looking among regular rules)\n    root.walkRules(function (rule) {\n      var selector = rule.selector;\n      // Just a shorthand for calling `parseSelector`\n\n      function parse(selector) {\n        (0, _utils.parseSelector)(selector, result, rule, function (s) {\n          return checkSelector(s, rule);\n        });\n      }\n\n      // If it's a custom prop or a less mixin\n      if (!(0, _utils.isStandardRule)(rule)) {\n        return;\n      }\n      // If the selector has interpolation\n      if (!(0, _utils.isStandardSelector)(selector)) {\n        return;\n      }\n\n      // Nested selectors are processed in steps, as nesting levels are resolved.\n      // Here we skip processing intermediate parts of selectors (to process only fully resolved selectors)\n      // if (rule.nodes.some(node => node.type === \"rule\" || node.type === \"atrule\")) { return }\n\n      // Only resolve selectors that have an interpolating \"&\"\n      if ((0, _utils.hasInterpolatingAmpersand)(selector)) {\n        (0, _postcssResolveNestedSelector2.default)(selector, rule).forEach(parse);\n      } else {\n        parse(selector);\n      }\n    });\n\n    function checkSelector(fullSelector, rule) {\n      // postcss-selector-parser gives %placeholders' nodes a \"tag\" type\n      fullSelector.walkTags(function (compoundSelector) {\n        var value = compoundSelector.value,\n            sourceIndex = compoundSelector.sourceIndex;\n\n        if (value[0] !== \"%\") {\n          return;\n        }\n        var placeholder = value.slice(1);\n\n        if (placeholderPattern.test(placeholder)) {\n          return;\n        }\n        _stylelint.utils.report({\n          result: result,\n          ruleName: ruleName,\n          message: messages.expected(placeholder),\n          node: rule,\n          index: sourceIndex\n        });\n      });\n    }\n  };\n};\n\nvar _lodash = require(\"lodash\");\n\nvar _postcssResolveNestedSelector = require(\"postcss-resolve-nested-selector\");\n\nvar _postcssResolveNestedSelector2 = _interopRequireDefault(_postcssResolveNestedSelector);\n\nvar _stylelint = require(\"stylelint\");\n\nvar _utils = require(\"../../utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"percent-placeholder-pattern\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  expected: function expected(placeholder) {\n    return \"Expected %-placeholder \\\"%\" + placeholder + \"\\\" to match specified pattern\";\n  }\n});","/home/travis/build/npmtest/node-npmtest-stylelint-scss/node_modules/stylelint-scss/dist/rules/selector-no-redundant-nesting-selector/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.messages = exports.ruleName = undefined;\n\nexports.default = function (actual) {\n  return function (root, result) {\n    var validOptions = _stylelint.utils.validateOptions(result, ruleName, { actual: actual });\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkRules(/&/, function (rule) {\n      var selector = rule.selector;\n      // \"Ampersand followed by a combinator followed by non-combinator non-ampersand and not the selector end\"\n\n      var regex = /^&\\s*[>+~ ]\\s*[^>+~ {&]+/;\n\n      if (selector === \"&\" || regex.test(selector)) {\n        _stylelint.utils.report({\n          ruleName: ruleName,\n          result: result,\n          node: rule,\n          message: messages.rejected\n        });\n      }\n    });\n  };\n};\n\nvar _stylelint = require(\"stylelint\");\n\nvar _utils = require(\"../../utils\");\n\nvar ruleName = exports.ruleName = (0, _utils.namespace)(\"selector-no-redundant-nesting-selector\");\n\nvar messages = exports.messages = _stylelint.utils.ruleMessages(ruleName, {\n  rejected: \"Unnecessary nesting selector (&)\"\n});"}